[
  {
    "categoryId": "5",
    "categoryName": "회고",
    "slug": "블로그를 배포하며",
    "content": "<p>{intro}</p>\n<Spacing size=\"lg\" />\n## 새로운 도전을 앞두고\n<br/>\n개발 블로그를 해야겠다는 생각은 몇 년 전부터 계속 하고 있었습니다. 다만 생각만 할 뿐 실천은 못하고 있는 상태였습니다. 그러다 작년 Next.js를 공부하며 만든 블로그를 실제로 운영해보기로 결심했지만 내가 개발 블로그를 할 수 있을까 싶은 망설임과 바빠서 시간이 나지 않는다는 핑계로 블로그는 점점 뒷전이 되었습니다. (블로그 : Remember Me🥹)\n<br/>\n올해 4월 디즈니 애니메이션 '코코'를 보았습니다. 눈물 버튼으로 유명한 영화여서 '절대 안울어야지' 다짐 했지만 눈물을 흘리며 영화관에서 나와버렸습니다.\n코코는 음악이 하고 싶은 소년 미구엘(~~기타치는 검은 머리 소년이 코코죠?~~)과 음악을 극도로 싫어하는 가족들과의 갈등을 풀어나가는 내용으로 당연하게도 미구엘과 가족들을 중심으로 이야기가 진행됩니다. \n<br/>\n그런데 영화를 보고나서 가장 기억에 남은 인물은 따로 있었습니다.\n<br/>\n<YoutubePlayer videoId=\"OF9Ixfq4BCI\" elementId=\"youtube\" start={355}/>\n***\"내가 너의 첫번째 청중이 될게.\"***\n<br/>\n바로 미구엘이 구두를 닦아주던 악사 아저씨입니다. 광장에서 개최되는 음악 페스티벌에 나갈지 말지 고민하던 미구엘에게 기회를 포착하라는 응원과 함께 자신의 기타를 내어주는 장면이 굉장히 인상 깊었습니다. 위 예고편에 나온 분량이 거의 다일 정도록 짧게 스쳐지나가는 조연 캐릭터가 계속 생각 났던 것은 어쩌면 미구엘처럼 새로운 도전을 망설이는 제가 듣고 싶었던 말을 해주었기 때문일지도 모르겠습니다. 그리고 언젠가는 저도 도전을 시작하는 사람에게 용기를 복돋아 주는 사람이 되고 싶다는 생각이 들었습니다. (하지만 모르는 꼬마 개발자한테 맥북 건네주기는 좀 어려울지도요?👩‍🦲)\n어쨌든 지금은 망설이기보단 도전할 때라고 생각합니다.\n<br/>\n## 창피하지만, 일단 배포합니다.\n<br/>\n블로그를 만들기 시작하면서 정말 여러 고비가 있었습니다. 특히 블로그 디자인이 꽤나 고역이었습니다. 늘 디자인을 받아서 구현하기만 했지 스스로 디자인 했던 경험은 퍼블리싱을 처음 시작하며 포트폴리오를 만들 때 뿐이었습니다. 어찌저찌 완성했지만 기대를 충족하지 못하는 퀄리티에 명색이 프론트엔드 개발자의 블로그인데 이게 맞나..? 싶었습니다.",
    "title": "블로그를 배포하며",
    "intro": "블로그를 배포하며 그동안 느낀 생각을 회고해봅니다. 블로그를 만드는 과정 자체는 재밌었지만 막상 배포하는 것은 왜 계속 망설여졌는지, 앞으로 어떻게 블로그를 운영해 나갈 예정인지에 대한 이야기를 해보겠습니다.",
    "isFeatured": true,
    "createdAt": "2024-09-02",
    "thumbnail": "https://drive.google.com/uc?export=view&id=1Pzdw0Swu61uaNzkDeMVpjnejLY_V3rfc",
    "keywords": "블로그, 회고"
  },
  {
    "categoryId": "1",
    "categoryName": "Javascript",
    "slug": "실행-컨텍스트-알아보기",
    "content": "<p>{intro}</p>\n<Spacing size=\"lg\" />\n## 실행 컨텍스트란?\n<br/>\n실행 컨텍스트란 코드를 실행할 때 필요한 문맥을 의미합니다. 글을 읽을 때 문맥을 파악하라는 말을 자주 하죠? 어휘의 의미와 문장의 앞 뒤 상황을 이해하여 글의 흐름을 파악하라는 말인데요. 실행 컨텍스트도 이와 비슷합니다. **실행 컨텍스트는 코드의 실행과 관련된 환경 정보**입니다. 이를 통해 현재 실행되는 코드 내의 식별자 정보와 외부 환경 참조, 함수 실행 순서 등을 관리하게 되는 것이죠.\n<br/>\n## 실행 컨텍스트의 생성/제거 시점\n<br/>\n실행 컨텍스트는 코드가 실행되기 전 생성되며, 코드 실행이 완료되면 제거됩니다. \n자바스크립트 소스 코드 타입에 따른 실행 컨텍스트가 생성/제거 시점은 다음과 같습니다\n<br/>\n### - 전역 코드\n함수, 코드 블럭 외부의 코드로 코드가 처음 실행될 때 컨텍스트가 생성되고 페이지가 종료될 때까지 유지됩니다.\n<br/>\n### - 함수 코드\n함수 내부에 존재하는 코드로 함수가 호출 될 때 컨텍스트가 생성되고 함수가 종료되는 시점에서 컨텍스트가 제거됩니다. if문, for문과 같은 문(statement)에서는 실행 컨텍스트가 생성되지 않습니다.\n<br/>\n### - eval 코드\n 문자열로 표현된 코드를 실행할 수 있게 해주는 **eval** 함수에 인수로 전달되어 실행되는 코드입니다. eval 함수가 호출될 때 컨텍스트가 생성되고, **eval** 함수가 실행한 코드가 종료되는 시점에 컨텍스트가 종료됩니다.",
    "title": "실행 컨텍스트란 알아보기",
    "intro": "이전에 변수 이야기를 하며 호이스팅, 스코프 체인 이야기를 언급했는데요. 왜 그런 현상이 일어나는지 궁금하지 않으셨나요? 실행 컨텍스트를 알게 되면 많은 궁금증이 풀리게 됩니다. 얼른 실행 컨텍스트에 대해 알아보러 갑시다.",
    "isFeatured": true,
    "createdAt": "2024-08-12",
    "thumbnail": "https://drive.google.com/uc?export=view&id=159jGroEmKvVBVvLL9C77eprzuvnbccBn",
    "keywords": "자바스크립트, javascript, 실행 컨텍스트, execution context, call stack, hoisting, scope"
  },
  {
    "categoryId": "1",
    "categoryName": "Javascript",
    "slug": "this-바인딩-알아보기",
    "content": "<p>{intro}</p>\n<Spacing size=\"lg\" />\n\n## this란 무엇일까요?\n<br/> \nthis는 자신이 속한 객체 또는 자신이 생성할 인스턴스를 가리키는 자기 참조 변수를 의미합니다. this를 통해 자신이 속한 객체 또는 생성할 인스턴스의 프로퍼티나 메서드에 접근할 수 있게 됩니다.\n<br/> \n```javascript\nconst kevin = {\n  name: \"케빈\",\n  introduce() {\n\t  console.log(`Bello! Me ${this.name}!`);\n  },\n  printThis() {\n\t  console.log(this);\n  },\n};\n\nkevin.introduce(); // \"Bello! Me 케빈!\"\nkevin.printThis();\n```\n<br/>\n<PostImage src=\"https://drive.google.com/uc?export=view&id=1DbVWd26uvnbjZZlv2-qhu8zTz3xunho0\" alt=\"kevin 객체의 this\" width=\"600\" height=\"139\" caption=\"kevin.printThis의 출력 값, this는 kevin 객체.\"/>\n<br/> \n이렇게 this를 통해 객체에 정의된 name에 접근할 수 있습니다.\n<br/> \n<Callout title=\"객체 메서드 축약 표현\">\n객체에서 메서드를 선언할 때 ES6에서 나온 객체 메서드 축약 표현을 사용하는 것을 권장합니다.\n자바스크립트에서 function 키워드를 사용하여 함수를 선언하면 해당 함수는 일반 함수와 생성자 함수로 모두 사용할 수 있는데요. 이는 function 키워드로 선언된 함수의 프로토타입에 생성자 함수 관련 기능이 포함되어 있기 때문입니다. \n</Callout>\n<br/> \n```javascript\nconst kevin = {\n\tname: \"케빈\",\n  introduce: function () {\n\t  console.log(`Bello! Me ${this.name}!`);\n  }\n};\n  \nconst kevinInstance = new kevin.introduce();\nconsole.log(kevinInstance);\n```\n<br/>  \n<PostImage src=\"https://drive.google.com/uc?export=view&id=1826Ks3SsmqI7Hm7WPpxX_rexAVAnB_RC\" alt=\"function 키워드를 사용하면 객체 내에 선언된 메서드 임에도 생성자 함수 역할이 가능.\" width=\"540\" height=\"90\" caption=\"kevin.introduce 함수로 생성된 인스턴스\"/>\n<br/> \n<Callout icon=\"none\">\nfunction 키워드를 사용하여 만든 kevin.introduce 메서드는 인스턴스를 만들 수 있는 생성자 함수의 기능도 가지고 있습니다🫢 생성자 함수 관련 기능을 사용하지 않는데 관련 내용을 상속 받으니 비효율적입니다. \n그럼 이제 객체 메서드 축약 표현을 사용해볼까요?\n</Callout>    \n<br/> \n```javascript\nconst kevin = {\n\tname: \"케빈\",\n  introduce () {\n\t  console.log(`Bello! Me ${this.name}!`);\n  }\n};\n\nconst kevinInstance = new kevin.introduce();\nconsole.log(kevinInstance)\n```\n<br/>\n<PostImage src=\"https://drive.google.com/uc?export=view&id=10pKBD9ysTG8Mi_p1G8vR1fuV8SWlVXdy\" alt=\"객체 축약 표현 사용 시 인스턴스를 생성할 수 없음\" width=\"600\" height=\"69\"/>  \n<br/>\n<Callout icon=\"none\">\n객체 메서드 축약 표현으로 선언된 메서드로 인스턴스를 생성하려고 하면 kevin.introduce is not a constructor 에러가 뜨는 것을 확인할 수 있죠. 생성자 함수 관련 상속을 받지 않는 것을 알 수 있습니다. 때문에 보기에도 간결하고 성능도 좋은 객체 메서드 축약 표현을 사용하는 것을 추천드립니다.\n</Callout> \n<br/>\n<br/>\n<Callout icon=\"🤔\" title=\"객체의 프로퍼티에서 this를 사용하면 어떻게 될까?\">\n 혹시 객체 리터럴로 객체를 정의할 때 객체 프로퍼티에서 this를 사용해보려고 하신 적이 있나요? (저는 있습니다😅) 프로퍼티에서 this를 참조하면 전역객체가 나오는데요. 객체 리터럴은 실행 컨텍스트를 생성하지 않기 때문에 상위 스코프인 전역 스코프의 this, 즉 전역객체가 this가 됩니다. 그러나 메서드는 함수이기 때문에 함수 호출 시 실행 컨텍스트가 생성되고 this가 바인딩됩니다. 이때 this는 호출 주체인 객체가 됩니다. (예시코드에서는 kevin)\n</Callout>",
    "title": "this 바인딩 알아보기",
    "intro": "자바스크립트에서 this를 사용해보신 적이 있으신가요? 아마 생각과 다른 값이 나와 당황스러우셨던 적도 있을 것 같은데요. 자바스크립트에서 this는 함수 호출 방식에 따라 값이 동적으로 바인딩 되기 때문에 이에 대해 잘 알아두지 않으면 함정에 빠지게 되는 경우가 종종 있습니다. this 바인딩에 대해 정리해보며 함정을 슉슉 피할 수 있는 슈퍼 개발자가 되어보겠습니다.",
    "isFeatured": true,
    "createdAt": "2024-08-08",
    "thumbnail": "https://drive.google.com/uc?export=view&id=1SKIK-J9lzuVqUZEZXkvbAX09u5z4B5OT",
    "keywords": "자바스크립트, javascript, this, this 바인딩, this binding, arrow function, call, apply, bind"
  },
  {
    "categoryId": "1",
    "categoryName": "Javascript",
    "slug": "프로토타입(ProtoType)-알아보기",
    "content": "<p>{intro}</p>\n<Spacing size=\"lg\" />\n\n## 프로토타입이란?\n<br/>\n 사전적 의미의 프로토타입은 원래의 형태 또는 전형적인 예, 기초 또는 표준입니다. 원래의 형태, 즉 원형에 주목하여 자바스크립트에서의 프로토타입을 정의하면 **특정 객체의 원형이 되는 부모 객체**라고 할 수 있습니다. 자바스크립트에서 대부분의 객체는 원형 객체, 즉 프로토타입을 가지게 되며 프로토타입에 있는 프로퍼티와 메서드를 상속 받아 사용할 수 있게 됩니다.\n<br/>\n```javascript\nconst obj = {};\n\nconsole.log(obj)\n\nconsole.log(obj.[[Prototype]]);\n// SyntaxError: Unexpected token '['\nconsole.log(Object.getPrototypeOf(obj))\n```\n<br/>\n<PostImage src=\"https://drive.google.com/uc?export=view&id=1rxr4x95OyzOjQky0mx6QH4HSLJt6xDR6\" alt=\"obj의 프로토타입\" width=\"400\" height=\"263\" />\n<br/>\n객체 리터럴을 통해 빈 객체 obj를 만들고 콘솔을 통해 확인해보면 [[prototype]]에 Object 프로토타입이 존재하는 것을 확인할 수 있습니다. 또한 프로토타입에 정의된 메서드를 사용할 수도 있죠.\n<br/>\n다만 직접 프로토타입에 접근하려고 할 때 obj.[[Prototype]]으로는 접근할 수 없고 Object.getPrototypeOf() 메서드를 사용하여 객체의 프로토타입에 접근할 수 있습니다. \n<br/>\n\n<br/>\n## 프로토타입을 사용하는 이유\n<br/>\n**자바스크립트는 객체 지향 프로그래밍 언어**입니다. 객체 지향 프로그래밍이란 데이터를 객체 단위로 묶고, 객체 간의 상호작용을 통해 프로그램을 구성하는 방식을 말하는데요. \n객체 지향 프로그래밍의 특징으로는 **각 객체 간의 공통된 속성(프로퍼티)과 기능(메서드)을 추려 정의**하는 <HighlightText type=\"background\" fontWeight={700}>추상화</HighlightText>가 있습니다.\n<br/>\n아이돌 그룹 에스파를 예로 들어볼까요? (사심 1000%)\n<br/>\n에스파 각 멤버들의 공통된 속성을 떠올려봅시다. 멤버들은 이름, 포지션(메인보컬, 메인 댄서…)과 같은 속성(프로퍼티)을 가지고 있을 것이고 랩, 댄스, 노래와 같은 공통된 기능(메서드)을 수행합니다. 이렇게 공통된 특징을 추리고 정의하는 것을 추상화라고 합니다.  \n<br/>\n```javascript\nfunction Idol(name, role) { \n// 각 멤버들의 공통된 속성과 기능을 정의 (추상화)\n\tthis.name = name;\n    this.role = role;\n    this.rap = () => {\n\t\tconsole.log(`${this.name}이(가) 랩을 한다.`);\n    };\n    this.dance = () => {\n\t    console.log(`${this.name}이(가) 춤을 춘다.`);\n    };\n    this.sing = () => {\n\t    console.log(`${this.name}이(가) 노래를 한다.`);\n    };\n}\n\n// Idol 생성자 함수를 통해 멤버(instance) 생성\nconst karina = new Idol(\"카리나\", \"메인 댄서\"); \nconst winter = new Idol(\"윈터\", \"메인 보컬\");\nconst ningning = new Idol(\"닝닝\", \"리드 보컬\");\nconst giselle = new Idol(\"지젤\", \"메인 랩퍼\");\n\nconsole.log(karina);\nconsole.log(winter);\nconsole.log(ningning);\nconsole.log(giselle);\n\n```\n<br/>\n<PostImage src=\"https://drive.google.com/uc?export=view&id=15Y3Ftl1Ka_r0jI3BEx7tEThXU107Yhmk\" alt=\"프로토타입 체이닝\" width=\"400\" height=\"449\"/>\n<br/>\n이렇게 각 멤버들의 공통된 프로퍼티와 메서드를 추상화하여 Idol 생성자 함수를 만들고 생성자 함수를 통해 멤버(인스턴스)들을 만들 수 있게 되었습니다. \n<br/>\n그런데 name과 role처럼 인스턴스마다 고유한 값을 가지는 경우가 아닌 항상 동일한 기능을 수행하는 rap, dance, sing을 살펴봅시다. 완전히 같은 기능을 수행하는 메서드가 각 인스턴스 마다 포함되어 있는데요. 이렇게 되면 생성자 함수를 통해 만들어진 인스턴스의 수만큼 같은 코드가 중복으로 생성되게 됩니다. 실제로 각 메서드는 완전히 동일하지만 각각 중복으로 메모리에 저장되어있기 때문에 값을 비교하면 false가 나오게 되는 것을 알 수 있습니다.\n<br/>\n ```javascript\nconsole.log(karina.dance === winter.dance); // false\n```\n<br/>\n이처럼 인스턴스가 생성될 때마다 같은 코드가 중복으로 생성되어 메모리에 저장된다면 프로그램의 성능이 저하될 수 있겠죠.\n<br/>\n이런 불필요한 중복 방지를 위해 필요한 것이 바로 <HighlightText type=\"background\" fontWeight={700}>상속</HighlightText>입니다. 상속이란 **특정 객체의 속성이나 프로퍼티를 다른 객체가 그대로 이어받아 사용할 수 있는 것**을 말합니다. 그리고 자바스크립트는 바로 프로토타입을 사용하여 상속을 구현합니다.\n<br/>\n```javascript\nfunction Idol(name, role) {\n\tthis.name = name;\n    this.role = role;\n}\n\nIdol.prototype.rap = () => {\n    console.log(`${this.name}이(가) 랩을 한다.`);\n};\nIdol.prototype.dance = () => {\n\tconsole.log(`${this.name}이(가) 춤을 춘다.`);\n};\nIdol.prototype.sing = () => {\n\tconsole.log(`${this.name}이(가) 노래를 한다.`);\n};\n\nconst karina = new Idol(\"카리나\", \"메인 댄서\"); \nconst winter = new Idol(\"윈터\", \"메인 보컬\");\n\nconsole.log(karina.dance === winter.dance); //true\n```\n<br/>\n생성자 함수를 통해 생성된 인스턴스는 해당 생성자 함수의 prototype 프로퍼티를 프로토타입으로 가지는데요.\n(저는 예전에 karina의 프로토타입이 Idol이라고 착각한 적이 있는데 Idol은 생성자함수인 것이고 Idol.prototype이 karina의 프로토타입이 됩니다.)\n<br/>\n위와 같이 Idol.prototype을 통해 공통된 메서드를 정의하게 된다면 이제 모든 인스턴스들은 프로토타입에 정의된 메서드를 상속받아 사용할 수 있게 되고 더이상 여러번의 불필요한 코드 중복을 발생시키지 않게 됩니다. karina.dance와 winter.dance를 비교해도 true가 나오는 것을 알 수가 있습니다.\n<br/>\n이처럼 프로토타입은 자바스크립트의 객체 지향 프로그래밍에서 상속을 구현할 수 있게 하며 자바스크립트가 프로토타입 기반의 객체 지향 언어라고 불리는 이유이기도 합니다.\n<br/>\n## 상속 구현하기\n<br/>\n이제 우리는 프로토타입이 무엇인지 프로토타입을 왜 사용하는지에 대해 알게 되었습니다.",
    "title": "프로토타입(ProtoType) 알아보기",
    "intro": "예전에 같이 일하던 프론트엔드 개발자님께 ‘프로토타입이 뭔지 아시나요?’란 질문을 받은 적이 있는데요. 머리 속에 둥둥 떠오르는 내용들을 말로 설명하기 어려웠던 기억이 납니다. 공부를 하다보면 강의를 듣거나 문서를 읽은 것만으로 이해했다고 착각하기 쉬운 것 같습니다. 머리로 어렴풋하게 알고 있는 것과 실제로 다른 사람에게 말로 설명하는 것에는 아주 큰 차이가 있는데 말이죠. 오늘은 제가 알고 있다고 착각했던 프로토타입에 대해 정리해보겠습니다.",
    "isFeatured": true,
    "createdAt": "2024-08-02",
    "thumbnail": "https://drive.google.com/uc?export=view&id=1c0_ly-NQ_bRsw2up4RqKkFfETN_97aJF",
    "keywords": "자바스크립트, javascript, 프로토타입, prototype, 객체 지향, 상속"
  },
  {
    "categoryId": "1",
    "categoryName": "Javascript",
    "slug": "원시형과-객체형",
    "content": "<p>{intro}</p>\n<Spacing size=\"lg\" />\n\n## 원시 타입 (Primitive Type)\n<br/>\n- 원시타입에는 총 6가지의 데이터 타입이 있습니다. (아래 표 참고)\n- 변수에 **실제 값이 직접 저장**되는 데이터 타입입니다.\n- **불변한(immutable)** 값이며 재할당 시 기존 메모리 공간을 덮어 쓰는 것이 아니라 새로운 메모리 공간에 값을 저장하고 식별자는 새로운 메모리 주소를 가리키게 됩니다.\n- 원시 값을 갖는 변수를 다른 변수에 복사하면 원본의 **값 자체가 복사**됩니다.\n<br/>\n| 데이터 타입  | 예시 값 | 부연 설명 |\n| --- | --- | --- |\n| 문자열 (string) 타입  | ‘가나다’, ‘1234’ |  |\n| 숫자 (number) 타입  | 123, -123, infinite, NaN (Not a Number) | |\n| boolean 타입  | 논리 값, 참 (true)과 거짓 (false) | |\n| undefined 타입 | undefined (변수에 값이 할당되지 않았을 때 초기 값) |  |\n| null 타입 | null (’값이 없음’을 명시할 때 사용) |  typeof 사용 시 object가 나옴  |\n| symbol 타입 | 변경 불가능한 원시타입 값 | |\n<br/>\n<PostImage src=\"https://drive.google.com/uc?export=view&id=1SeVPcTnmDHVUgCGwWAcncEzvDP-kJsBt\" alt=\"원시형 데이터\" width=\"660\" height=\"795\"/>\n> 1. 실제 값 123456가 password 변수에 저장됩니다.\n> 2. password를 복사한 copyPassword는 password의 값 123456을 복사합니다.\n> 3. password에 654321로 값을 재할당하면 기존의 123456 값을 수정하는 것이 아니라 새로운 메모리 공간에 저장되며 password 식별자는 새로운 값이 담긴 메모리 주소를 가르킵니다.\n\n<br/>\n<Callout title=\"데이터 타입을 확인하고 싶을땐?\">\ntypeof 연산자를 사용하면 데이터 타입을 문자열로 반환합니다.\n</Callout> \n<br/>\n```javascript\nconsole.log(typeof true); // boolean\nconsole.log(typeof \"true\") //string\n```\n<br/>\n## 객체 타입 (Object Type)\n<br/>\n- 원시형 데이터가 아닌 모든 데이터 타입이 객체 타입 데이터입니다. (객체, 배열, 함수 등)\n- 객체 데이터는 **크기가 동적으로 바뀔 수 있기에 힙 메모리에 저장**되며 변수에는 **데이터의 메모리 주소가 저장**됩니다.\n- **변경 가능(mutable)**한 값이며 객체의 프로퍼티를 바꾸는 것이 가능합니다.\n- 객체 타입 변수를 다른 변수에 복사하면 원본의 **메모리 주소 값이 복사**됩니다.\n- 같은 주소를 바라보고 있기 때문에 **복사한 객체를 수정하면 원본 객체도 같이 수정됩니다.**\n<br/>\n<PostImage src=\"https://drive.google.com/uc?export=view&id=1PlT7EDKxpr3AAoqW9WGBHwYvJO8Ymkr3\" alt=\"\" width=\"660\" height=\"972\"/>\n<br/>\n> 1. userInfo는 객체가 저장된 주소를 저장합니다.\n> 2. copyUserInfo는 userInfo 객체가 저장된 주소 값을 복사합니다.\n> 3. 객체 타입 데이터는 변경 가능한 값이므로 프로퍼티를 바꾸는 것이 가능합니다. userInfo.name이 '김유저'에서 '이유저'로 변경\n> 4. userInfo와 copyUserInfo는 같은 객체를 참조하고 있기 때문에 userInfo.name도 '이유저'가 됩니다. \n\n<br/>\n<Callout title=\"배열은 무슨 타입일까?\">\narray는 배열이지만 데이터 타입은 **object**로 나오는 걸 볼 수 있습니다. 객체형 데이터 중 function만 예외적으로 **function** 타입을 반환합니다.\nArray.isArray() 메서드를 사용하여 배열인지 아닌지 확인할 수 있습니다.\n</Callout>\n\n<br/>\n```javascript\nconst array = [];\nconst func = function (){}\n\nconsole.log(typeof func) //function\nconsole.log(typeof array); // object\nconsole.log(Array.isArray(array)) //true\n\n```\n<br/>\n## 🚨객체형 데이터를 다룰 때 주의해야 할 점\n<br/>\n```javascript\nconst userInfo = {\n\tid: 1,\n\tname: \"김유저\",\n};\n\nconst copyUserInfo = userInfo;\n\ncopyUserInfo.name = \"이유저\"; // 복사한 객체에서 데이터 수정\n\nconsole.log(userInfo.name) // \"이유저\", 복사한 객체를 수정하였지만 원본 객체도 수정되었다!\n```\n<br/>\n위 코드 처럼 copyUserInfo를 수정하면 원본인 userInfo도 수정됩니다. **두 변수가 같은 메모리 주소를 바라보고 있기 때문입니다.** 원본을 수정하려고 의도한 것이 아니었다면 예기치 못한 에러가 날 수도 있겠죠. 때문에 객체형 데이터를 복사할 때는 원본 데이터에 영향을 미치지 않도록 **불변성을 유지하는 것이 중요합니다.**\n<br/>\n## 불변성을 유지하며 객체 타입 복사하기\n<br/>\n객체의 복사는 얕은 복사와 깊은 복사가 있습니다. <HighlightText type=\"background\" fontWeight={700}>얕은 복사</HighlightText>란 **복사 데이터의 속성이 원본 데이터와 같은 참조를 공유하는 경우**이고 <HighlightText type=\"background\" fontWeight={700}>깊은 복사</HighlightText>는 **원본 데이터와 공유하는 참조값이 없는 복사**로 원본 데이터의 불변성을 유지할 수 있습니다.",
    "title": "원시형과 객체형",
    "intro": "자바스크립트에서 데이터는 크게 원시 타입, 객체 타입으로 구분됩니다. 데이터 타입에 대해 처음 배울 때는 원시형, 객체형의 특징 보다는 그 안에 포함된 각각의 타입에 더 집중해서 공부하였지만 실제로 프로젝트를 진행하면서 객체 타입 데이터의 특성 이해하는 것이 중요하다는 사실을 알게 되었습니다. 그렇기에 오늘은 원시 타입과 객체 타입의 특징과 함께 객체 타입 데이터를 다룰 때 조심해야 할 부분에 대해서 알아보도록 하겠습니다.",
    "isFeatured": false,
    "createdAt": "2024-07-28",
    "thumbnail": "https://drive.google.com/uc?export=view&id=12UVym-fm2t8p66hBEdPasA8RgGLkFqRw",
    "keywords": "자바스크립트, javascript, data type, 원시형, 객체형, 불변성"
  },
  {
    "categoryId": "1",
    "categoryName": "Javascript",
    "slug": "var는-왜-더이상-사용되지-않을까",
    "content": "<p>{intro}</p>\n<Spacing size=\"lg\" />\n\n## 프로그래밍에서 변수란?\n<br/>\n프로그래밍에서 변수란 **하나의 값을 저장하기 위해 이름이 붙은 메모리 공간**을 뜻합니다.\n<br/>\n```javascript \nvar password = 123456; \n```\n<br/>\n위와 같이 변수를 선언하고 값을 할당하면 3단계에 걸쳐 변수에 값이 저장됩니다.\n<br/>\n<PostImage src=\"https://drive.google.com/uc?export=view&id=1WtfApWevV7lzHhaKIx6mF-KktJy5wZBo\" alt=\"변수 선언 과정\" width=\"580\" height=\"392\"/>\n<br/>\n> 1. 선언 : 자바스크립트 엔진이 **변수의 식별자를 인식하는 단계**입니다. 식별자만 인식할 뿐 값이 저장되지는 않습니다.\n> 2. 초기화 : 변수 식별자가 인식된 후, **메모리 공간을 확보하고 초기값을 설정하는 단계**입니다. 이 때 식별자는 확보된 메모리 공간의 주소값을 가르킵니다. 초기 값이 명시되어 있지 않은 경우 undefined로 초기화 됩니다.\n> 3. 할당 : 식별자가 가르키고 있는 주소의 **메모리 공간에 값을 저장하는 단계**입니다.\n<br/>\n## var와 const, let의 차이\n<br/>\n이제 자바스크립트에서 변수를 선언할 때 사용하는 세가지 키워드 var와 const,let의 차이점에 대해 알아봅시다.\n<br/>\n### 1. 재선언 , 재할당 가능 여부\n<br/>\n#### 재선언과 재할당이란?\n<br/>\n**재선언** : 이미 선언된 변수 식별자를 다시 사용하여 변수를 선언하는 것을 의미합니다.\n<br/>\n```javascript \nvar password = 123456; \nvar password = 654321; // 이미 사용된 password 식별자를 사용하여 변수를 재선언\n\nconsole.log(654321); // 재선언 시 할당된 654321이 출력된다.\n```\n<br/>\n**재할당** : 변수에 값을 다시 할당하는 것을 의미합니다.\n<br/>\n```javascript \nvar password = 123456; \npassword = 654321; // password 값에 값을 재할당\n\nconsole.log(654321); // 재할당 된 654321 값이 출력된다.\n```\n<br/>\nvar와 const, let의 재선언, 재할당 여부는 아래와 같습니다.",
    "title": "var는 왜 더이상 사용되지 않을까",
    "subTitle": "var와 const, let의 차이점 알아보기",
    "intro": "혹시 자바스크립트에서 var 사용을 지양하라는 말을 들어보셨나요? \n var는 한때 자바스크립트에서 변수를 선언할 수 있는 유일한 키워드였습니다. 하지만 ES6부터 모던 자바스크립트를 사용하는 개발자들은 더 이상 var를 사용하지 않고 있습니다. ES6부터 포함된 const와 let이라는 변수 선언 키워드가 있기 때문입니다. 하지만 var를 사용하지 않는 이유가 그저 오래된 문법이라서일까요? var와 const, let의 차이점을 알아보며 var가 외면받는 이유에 대해 알아보겠습니다.",
    "isFeatured": true,
    "createdAt": "2024-07-24",
    "thumbnail": "https://drive.google.com/uc?export=view&id=1KhO3x8PP7eh40G3ux4RsEg40L32eVkuC",
    "keywords": "자바스크립트, javascript, 변수, variables, var, const, let, hoisting, 호이스팅, scope"
  }
]
