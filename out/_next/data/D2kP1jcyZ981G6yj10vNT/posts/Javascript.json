{"pageProps":{"postList":[{"categoryId":"1","categoryName":"Javascript","slug":"실행-컨텍스트란","content":"<p>{intro}</p>\n<Spacing size=\"lg\" />\n## 실행 컨텍스트란?\n<br/>\n실행 컨텍스트란 코드를 실행할 때 필요한 문맥을 의미합니다. 글을 읽을 때 문맥을 파악하라는 말을 자주 하죠? 어휘의 의미와 문장의 앞 뒤 상황을 이해하여 글의 흐름을 파악하라는 말인데요. 실행 컨텍스트도 이와 비슷합니다. **실행 컨텍스트는 코드의 실행과 관련된 환경 정보**입니다. 이를 통해 현재 실행되는 코드 내의 식별자 정보와 외부 환경 참조, 함수 실행 순서 등을 관리하게 되는 것이죠.\n<br/>\n## 실행 컨텍스트의 생성/제거 시점\n<br/>\n실행 컨텍스트는 코드가 실행되기 전 생성되며, 코드 실행이 완료되면 제거됩니다. \n자바스크립트 소스 코드 타입에 따른 실행 컨텍스트가 생성/제거 시점은 다음과 같습니다\n<br/>\n### - 전역 코드\n함수, 코드 블럭 외부의 코드로 코드가 처음 실행될 때 컨텍스트가 생성되고 페이지가 종료될 때까지 유지됩니다.\n<br/>\n### - 함수 코드\n함수 내부에 존재하는 코드로 함수가 호출 될 때 컨텍스트가 생성되고 함수가 종료되는 시점에서 컨텍스트가 제거됩니다. if문, for문과 같은 문(statement)에서는 실행 컨텍스트가 생성되지 않습니다.\n<br/>\n### - eval 코드\n 문자열로 표현된 코드를 실행할 수 있게 해주는 **eval** 함수에 인수로 전달되어 실행되는 코드입니다. eval 함수가 호출될 때 컨텍스트가 생성되고, **eval** 함수가 실행한 코드가 종료되는 시점에 컨텍스트가 종료됩니다.\n<br/>\n<Callout icon=\"🚨\">\neval은 문자열로 입력받은 코드가 악의적인 내용을 포함하는 등 보안상 위험이 생길 수 있기에 사용을 지양하고 있습니다.\n</Callout>\n<br/>\n### - module 코드\n자바스크립트 module 내부에 존재하는 코드로 module이 import 되는 순간 컨텍스트가 생성되며 해당 모듈 코드가 종료될 때 컨텍스트가 제거됩니다.\n<br/>\n## 콜 스택을 통한 함수 실행 순서 관리\n<br/>\n일단 콜 스택에 대해 알아보기 전에, 스택에 대해 알고 계시나요? 스택이란 후입선출(LIFO, Last In First Out) 방식의 자료구조를 의미합니다. 즉, **마지막에 들어온 데이터가 가장 먼저 나가게 되는 것**이죠.\n<br/>\n<PostImage src=\"https://drive.google.com/uc?export=view&id=14L-2EurAc37t_OeTgtjXLR3eDdOuTTSe\" alt=\"스택\" width=\"375\" height=\"439\"/>\n<br/>\n콜 스택은 자바스크립트에서 함수 호출 시 생성되는 실행 컨텍스트를 관리하는 스택 자료구조인데요. 함수가 호출될 때 마다 콜 스택에 호출된 함수의 실행 컨텍스트가 차곡차곡 쌓이게 됩니다. 이때 가장 위에 쌓인 실행 컨텍스트를 가진 함수가 가장 먼저 실행됩니다. 즉 가장 니중에 호출된 함수가 가장 먼저 실행되는 것이죠. \n<br/>\n함수 실행이 완료되면, 그 함수의 실행 컨텍스트는 콜 스택에서 제거되고 그 다음으로 쌓인 실행 컨텍스트의 함수가 실행됩니다. 이렇게 콜 스택을 통해 함수의 실행 순서를 보장하게 되는 것이죠.\n<br/>\n```javascript\n\nconsole.log(\"1. 전역 컨텍스트\");\n\nfunction outerFunc () {\n\tconsole.log(\"1. outerFunc 컨텍스트\");\n\t\n\tfunction innerFunc () {\n\t\tconsole.log(\"2. innerFunc 컨텍스트\");\n\t}\n\t\n\tinnerFunc();\n}\n\nouterFunc();\n\nconsole.log(\"4. 함수 실행 컨텍스트가 모두 제거 된 후 전역 컨텍스트만 call stack에 남음\");\n```\n<br/>\n위와 같은 코드가 있을 때 콜 스택에 컨텍스트가 쌓이는 과정을 보겠습니다.\n<br/>\n<PostImage src=\"https://drive.google.com/uc?export=view&id=1Fce2nPOfLqWtHkuYP-4kPc6vDcyZosRs\" alt=\"실행 컨텍스트가 call stack에 쌓이는 과정\" width=\"688\" height=\"523\"/>\n<br/>\n> 1. 전역 컨텍스트 생성 -> 콜 스택에 쌓임 -> 'console.log(\"1. 전역 컨텍스트\")' 실행    \n> 2. outerFunc 호출 -> outerFunc 실행 컨텍스트 생성 -> 콜 스택에 쌓임 -> 'console.log(\"2. outerFunc 컨텍스트\");' 실행\n> 3. innerFunc 호출 -> innerFunc 실행 컨텍스트 생성 -> 콜 스택에 쌓임 -> 'console.log(\"3. innerFunc 컨텍스트\")' 실행\n> 4. innerFunc 함수 종료 -> 콜 스택에서 제거.\n> 5. outerFunc로 복귀 -> outerFunc 함수 종료 -> 콜 스택에서 제거.\n> 6. 전역 컨텍스트로 복귀 -> console.log(\"4. 함수 실행 컨텍스트가 모두 제거 된 후 전역 컨텍스트만 call stack에 남음\"); 실행, 전역 컨테스트는 페이지가 종료될 때 까지 유지.\n<br/>\n이와 같이 코드가 실행되다가 함수가 호출되면 해당 함수의 실행 컨텍스트가 콜스택에 쌓이게 되고 해당 함수가 실행됩니다. 함수가 종료되고 콜스택에서 제거되면 이전 컨텍스트의 함수가 이어서 실행되게 됩니다. \n<br/>\n## 실행 컨텍스트에 담긴 정보\n<br/>\n그럼 이제 실행 컨텍스트에 어떤 정보가 담겨있을지 알아보도록 하겠습니다.\n<br/>\n### - VariableEnvironment (변수 환경)\n<br/>\nVariableEnvironment는 컨텍스트 생성 시의 식별자 정보와 외부 환경 참조 정보를 가지고 있습니다. 컨텍스트 생성 될 때 컨텍스트의 내의 식별자를 수집합니다. var의 경우 수집과 동시에 undefined로 초기화됩니다. 컨텍스트 생성 당시의 상태를 기억하며 코드 진행 중에 값이 변경되지 않습니다. LexicalEnvironment와 동일한 구조를 가지기 때문에 자세한 구조에 대해선 LexicalEnvironment에서 이야기 해보겠습니다.  \n<br/>\n### - LexicalEnvironment (어휘적 환경)\n<br/>\nLexicalEnvironment 역시 식별자 정보와 외부 환경 참조 정보를 가지고 있습니다. 컨텍스트가 생성 될 시점에는 VariableEnvironment를 복사하기 때문에 값이 동일하지만 코드가 실행됨에 따라 식별자 정보를 업데이트 합니다. (const, let으로 선언한 변수의 초기화, 변수 값 할당, 재할당 등)\n<br/>\n#### - environmentRecord (환경 기록)\n컨텍스트 내에서 수집된 식별자 정보가 있습니다.\n<br/>\n#### - outerEnvironmentReference (외부 환경 참조)\n현재 실행 컨텍스트의 외부 환경을 참조하는 정보입니다. 현재 컨텍스트에 식별자가 존재하지 않을 경우 외부 스코프에서 식별자를 검색합니다. 이를 통해 상위 스코프의 식별자에 접근할 수 있는 것을 스코프체인이라고 합니다. 내부 함수에서는 외부 함수의 식별자를 참조할 수 있지만 외부 함수에서 내부 함수에 참조할 수 없는 이유이기도 합니다.\n<br/>\n<Callout title=\"호이스팅\">\n코드가 실행되기 전 식별자를 수집하는 과정에서 식별자가 코드의 상단으로 끌어올려진 것처럼 동작하는 호이스팅 현상이 발생하게 됩니다. 즉, 실제로 식별자가 코드 위로 끌어올려진 것이 아니라 **environmentRecord**에 수집된 식별자를 컨텍스트 내에서 접근할 수 있게 되는 것이죠. 이로인해 var를 사용한 변수 선언, 함수 선언문에 도달하지 않아도 해당 식별자에 접근할 수 있게 됩니다.\n</Callout>\n<br/>\n<Callout title=\"var와 const, let의 차이\">\nvar는 변수 선언이 수집됨과 동시에 undefined로 초기화 되기 때문에 변수 선언문 전에 해당 변수에 접근이 가능했습니다. 이런 예기치 못한 동작을 보완하기 위해 나온 const, let은 선언문 이전에 변수가 초기화 되지 않는데요. 코드가 실행됨에 따라 변수 선언문에 도달했을 때 비로소 변수가 초기화되고 LexicalEnvironment가 업데이트 됩니다. 따라서 세 가지 키워드로 선언된 변수 모두 호이스팅 현상이 발생하지만 const, let은 변수 수집 후 초기화 되기 이전 영역인 TMZ(일시적 사각지대)에서는 변수에 접근할 수 없기 때문에 변수 선언문 이전에 접근할 수 없게 되는 것이죠.\n</Callout>\n<br/>\n<Callout icon=\"🤔\" title=\"블록은 어떻게 스코프를 생성할까?\">\n실행 컨텍스트는 함수 호출 시에 생성된다고 이야기 했습니다. 그렇다면 블록에서는 어떻게 스코프가 만들어질까요? 바로 블록 코드가 실행될 때 LexicalEnvironment가 생성되기 떄문입니다. 이를 통해 블록 내부 식별자를 관리하고 스코프 체인을 통해 외부 환경의 식별자에도 접근할 수 있게 됩니다. 그리고 블록 내의 코드가 모두 종료 되었을 때 LexicalEnvironment가 제거됩니다.\n</Callout>\n<br/>\n### - ThisBinding(This 바인딩)\n<br/>\n**This Binding**은 **this**의 값을 결정하는 정보로, 함수 호출 시 **this**가 참조할 객체를 결정합니다.\n<br/>\n## 포스팅을 마무리하며\n<br/>\n이렇게 자바스크립트 코드가 실행될 때의 환경 정보인 실행 컨텍스트에 대해서 알아보았습니다. 이를 통해 호이스팅, 스코프 체이닝, this 바인딩 등 자바스크립트에서 발생하는 다양한 현상들에 대해 이해할 수 있었습니다. 이번 포스팅을 통해 원래 그런 것, 그냥 그런 것은 없다는 사실도 다시끔 느끼게 되었네요.  \n<br/>\n사실 실행 컨텍스트는 블로그를 시작하며 언젠가 꼭 다뤄야지 했던 주제입니다. 처음 변수 포스팅을 할 때도 '아 이걸 설명하려면 실행 컨텍스트 이야기를 해야하는데' 하면서 어디부터 어디까지 이야기해야하나 참 고민이 많았는데 이렇게 포스팅할 수 있게 되어서 숙제를 덜어낸 기분입니다. 그럼 후련한 마음으로 글을 마무리 하도록 하겠습니다. 여기까지 긴 글 읽어주셔서 감사합니다.😊","title":"실행 컨텍스트란?","intro":"이전에 변수 이야기를 하며 호이스팅, 스코프 체인 이야기를 언급했는데요. 왜 그런 현상이 일어나는지 궁금하지 않으셨나요? 실행 컨텍스트를 알게 되면 많은 궁금증이 풀리게 됩니다. 얼른 실행 컨텍스트에 대해 알아보러 갑시다.","isFeatured":true,"createdAt":"2024-08-12","thumbnail":"https://drive.google.com/uc?export=view&id=159jGroEmKvVBVvLL9C77eprzuvnbccBn","keywords":"자바스크립트, javascript, 실행 컨텍스트, execution context, call stack, hoisting, scope"},{"categoryId":"1","categoryName":"Javascript","slug":"this-바인딩-알아보기","content":"<p>{intro}</p>\n<Spacing size=\"lg\" />\n\n## this란 무엇일까요?\n<br/> \nthis는 자신이 속한 객체 또는 자신이 생성할 인스턴스를 가리키는 자기 참조 변수를 의미합니다. this를 통해 자신이 속한 객체 또는 생성할 인스턴스의 프로퍼티나 메서드에 접근할 수 있게 됩니다.\n<br/> \n```javascript\nconst kevin = {\n  name: \"케빈\",\n  introduce() {\n\t  console.log(`Bello! Me ${this.name}!`);\n  },\n  printThis() {\n\t  console.log(this);\n  },\n};\n\nkevin.introduce(); // \"Bello! Me 케빈!\"\nkevin.printThis();\n```\n<br/>\n<PostImage src=\"https://drive.google.com/uc?export=view&id=1DbVWd26uvnbjZZlv2-qhu8zTz3xunho0\" alt=\"kevin 객체의 this\" width=\"600\" height=\"139\" caption=\"kevin.printThis의 출력 값, this는 kevin 객체.\"/>\n<br/> \n이렇게 this를 통해 객체에 정의된 name에 접근할 수 있습니다.\n<br/> \n<Callout title=\"객체 메서드 축약 표현\">\n객체에서 메서드를 선언할 때 ES6에서 나온 객체 메서드 축약 표현을 사용하는 것을 권장합니다.\n자바스크립트에서 function 키워드를 사용하여 함수를 선언하면 해당 함수는 일반 함수와 생성자 함수로 모두 사용할 수 있는데요. 이는 function 키워드로 선언된 함수의 프로토타입에 생성자 함수 관련 기능이 포함되어 있기 때문입니다. \n</Callout>\n<br/> \n```javascript\nconst kevin = {\n\tname: \"케빈\",\n  introduce: function () {\n\t  console.log(`Bello! Me ${this.name}!`);\n  }\n};\n  \nconst kevinInstance = new kevin.introduce();\nconsole.log(kevinInstance);\n```\n<br/>  \n<PostImage src=\"https://drive.google.com/uc?export=view&id=1826Ks3SsmqI7Hm7WPpxX_rexAVAnB_RC\" alt=\"function 키워드를 사용하면 객체 내에 선언된 메서드 임에도 생성자 함수 역할이 가능.\" width=\"540\" height=\"90\" caption=\"kevin.introduce 함수로 생성된 인스턴스\"/>\n<br/> \n<Callout icon=\"none\">\nfunction 키워드를 사용하여 만든 kevin.introduce 메서드는 인스턴스를 만들 수 있는 생성자 함수의 기능도 가지고 있습니다🫢 생성자 함수 관련 기능을 사용하지 않는데 관련 내용을 상속 받으니 비효율적입니다. \n그럼 이제 객체 메서드 축약 표현을 사용해볼까요?\n</Callout>    \n<br/> \n```javascript\nconst kevin = {\n\tname: \"케빈\",\n  introduce () {\n\t  console.log(`Bello! Me ${this.name}!`);\n  }\n};\n\nconst kevinInstance = new kevin.introduce();\nconsole.log(kevinInstance)\n```\n<br/>\n<PostImage src=\"https://drive.google.com/uc?export=view&id=10pKBD9ysTG8Mi_p1G8vR1fuV8SWlVXdy\" alt=\"객체 축약 표현 사용 시 인스턴스를 생성할 수 없음\" width=\"600\" height=\"69\"/>  \n<br/>\n<Callout icon=\"none\">\n객체 메서드 축약 표현으로 선언된 메서드로 인스턴스를 생성하려고 하면 kevin.introduce is not a constructor 에러가 뜨는 것을 확인할 수 있죠. 생성자 함수 관련 상속을 받지 않는 것을 알 수 있습니다. 때문에 보기에도 간결하고 성능도 좋은 객체 메서드 축약 표현을 사용하는 것을 추천드립니다.\n</Callout> \n<br/>\n<br/>\n<Callout icon=\"🤔\" title=\"객체의 프로퍼티에서 this를 사용하면 어떻게 될까?\">\n 혹시 객체 리터럴로 객체를 정의할 때 객체 프로퍼티에서 this를 사용해보려고 하신 적이 있나요? (저는 있습니다😅) 프로퍼티에서 this를 참조하면 전역객체가 나오는데요. 객체 리터럴은 실행 컨텍스트를 생성하지 않기 때문에 상위 스코프인 전역 스코프의 this, 즉 전역객체가 this가 됩니다. 그러나 메서드는 함수이기 때문에 함수 호출 시 실행 컨텍스트가 생성되고 this가 바인딩됩니다. 이때 this는 호출 주체인 객체가 됩니다. (예시코드에서는 kevin)\n</Callout>  \n<br/>    \n```javascript\nconst kevin = {\n\tname: \"케빈\",\n  nickName: `용감한 ${this.name}`,\n};\n\nconsole.log(kevin.nickName); // kevin.nickName에서의 this는 전역객체\n```   \n<br/>\n<PostImage src=\"https://drive.google.com/uc?export=view&id=1CRKPnVsrMgTUqyCLYUx72Sun4FDH3ybd\" alt=\"객체의 프로퍼티에서 this를 사용하면 this는 전역객체\" width=\"380\" height=\"40\"/>   \n<br/>\nnickName 프로퍼티에서 this는 전역객체이므로 name이 출력되지 않고 있습니다. \n<br/>\n```javascript\nfunction Minion(name,character) {        \n\tthis.name = name;\n  this.character = character;        \n\tthis.nickName = `${this.character} ${this.name}`;        \n\tthis.introduce = function () {          \n\tconsole.log(`Bello! Me ${this.name}!`);        \n};        \n\tthis.printThis = function () {          \n\t\tconsole.log(this);       \n  }; \n}\n  \nconst kevin = new Minion(\"케빈\", \"용감한\");  \nconsole.log(kevin.nickName); //용감한 케빈  \nkevin.introduce(); //Bello Me 케빈!.    \nkevin.printThis();\n```\n<br/> \n<PostImage src=\"https://drive.google.com/uc?export=view&id=1r2txHNNN35zaypnusvX8DqudCGvNZG1a\" alt=\"생성자 함수는 호출 시 this가 정해지므로 프로퍼티에서의 this는 생성될 인스턴스\" width=\"600\" height=\"109\" caption=\"this는 kevin 인스턴스\"/>   \n<br/>\n생성자 함수에서는 메서드 뿐만 아니라 프로퍼티에서도 this를 사용하여 자기 자신을 참조하는 것이 가능합니다. 인스턴스의 생성 시점, 즉 생성자 함수 호출 시점에 this가 바인딩 되기 때문입니다.\n<br/>\n## this 바인딩이 중요한 이유\n<br/> \nthis 바인딩은 this가 가리킬 객체를 결정하는 것을 의미하는데요. 그렇다면 왜 this 바인딩이 중요할까요? \n바로 this가 동적으로 바인딩 되기 때문입니다. 아까 생성자 함수에서의 this를 설명하며 생성자 함수 호출 시점에 this가 바인딩된다고 언급했죠? 하지만 자바스크립트에서 this는 바인딩 된 이후에도 함수 호출 방식에 따라 동적으로 바뀌기 때문에 this 바인딩에 대해 알아두는 것이 중요합니다.\n<br/> \n## 문맥과 함수 호출에 따른 this 바인딩\n<br/>\n먼저 문맥과 함수 호출 방식에 따른 this 바인딩을 표로 정리해보면 이렇습니다.\n<br/> \n| 문맥 혹은 함수 호출 방식 | this |\n| --- | --- |\n| 전역 | 전역 객체 |\n| 일반 함수 호출 | 전역 객체 / strict mode에서는 undefined |\n| 메서드 호출 | 메서드를 호출한 객체 |\n| 생성자 함수 호출 | 생성자 함수가 생성할 인스턴스 |\n| 이벤트 리스너 함수 호출 | function 키워드 : 이벤트 리스너 함수가 등록된 DOM 요소 <br/> 화살표 함수 : 상위 스코프의 this |\n<br/> \n### 전역\n<br/> \n```javascript\nconsole.log(this); //Window\n```\n<br/>\n<PostImage src=\"https://drive.google.com/uc?export=view&id=1ATz33n8AzSSOdhBQmU7wiD2TS4n98SR4\" alt=\"Window 전역 객체\" width=\"600\" height=\"22\"/>\n<br/> \n전역에서의 this는 전역객체로 브라우저라면 Window, 노드 환경이라면 global이 됩니다. \n<br/> \n### 일반 함수 호출\n<br/> \n```javascript\nfunction func () {\n\tconsole.log(this);\n}\n\nfunc();  //Window\n\nfunction stricFunc () {\n\t'use strict'\n\tconsole.log(this);\n}\n\nstricFunc();  //undefined\n```\n<br/> \n일반 함수에서의 this는 전역 객체입니다. 다만 strict mode에서는 undefined가 됩니다. \n<br/> \n```javascript\nfunction Minion(name,character) {        \n \tthis.name = name;\n  this.character = character;        \n \tthis.nickName = `${this.character} ${this.name}`;        \n \tthis.introduce = function () {   \n    function getName () {\n      return this.name;\n    }       \n \t\tconsole.log(`Bello! Me ${getName()}!`);        \n \t};        \n \tthis.printThis = function () {          \n \t\tconsole.log(this);       \n  }; \n}\n\nconst stuart  = new Minion('스튜어트', \"기타치는\");\nconst introduce = stuart.introduce();\nstuart.printThis();\n```\n<br/> \n그렇다면 introduce 메서드 내부에서 getName 함수를 선언하고 호출하면 어떻게 될까요?\n<br/> \n<PostImage src=\"https://drive.google.com/uc?export=view&id=1jNQbtM89p2DszrK-nkr159T1oOpIbyyW\" alt=\"메서드 내 일반 함수는 전역객체가 바인딩\" width=\"422\" height=\"34\"/>\n<br/> \n이름이 출력되지 않고 있네요🤦‍♀️\n<br/> \ngetName은 일반 함수이기 때문에 this에 전역객체가 바인딩 되기 때문입니다. \n(이 문제를 해결하는 방법은 [this 정적 바인딩하기](#this-정적-바인딩하기)에서 알아보겠습니다.) \n<br/> \n### 메서드 호출\n<br/> \n```javascript\nconst bob = {\n\tname:\"밥\",\n  character:\"귀여운\",\n\tprintThis () {\n\t\tconsole.log(this)\n\t}  \n};\n\nbob.printThis();\n```\n<br/>\n<PostImage src=\"https://drive.google.com/uc?export=view&id=1gV5fpeEWkZlsZkaSmV1pTN1kO9nd38Vw\" alt=\"메서드의 this\" width=\"600\" height=\"151\" caption=\"this는 메서드 호출 주체 bob\"/>\n<br/> \n메서드 호출 시 this는 메서드를 호출한 객체입니다.\n<br/>\n```javascript\nconst bob = {\n\tname:\"밥\",\n\tplay () {\n\t\tconsole.log(`${this.name}와(과) 놀기`)\n\t}  \n};\n\nconst kevin = {\n\tname:\"케빈\",\n  character:\"용감한\"\n}\n\nkevin.play = bob.play;\nkevin.play();\n\n```\n<br/>\n<PostImage src=\"https://drive.google.com/uc?export=view&id=1aAuu9Vbbje2_aCZV7CSHZCFpst7D0eTH\" alt=\"메서드 호출 시 생성자 함수 호출 시점의 this와 상관 없이 메서드를 호출한 주체가 this\" width=\"260\" height=\"42\" caption=\"this는 메서드 호출 주체 kevin\"/>\n<br/> \n그렇다면 kevin 객체에 bob.play 메서드를 추가하고, kevin 객체가 play 메서드를 호출하면 어떻게 될까요? 호출 주체인 kevin이 this가 됩니다.\n<br/> \n```javascript\nconst stuart = {\n  name: \"스튜어트\",\n  play() {\n    console.log(`${this.name}와(과) 놀기`)\n  }\n}\n \nconst playWithStuart = stuart.play;\nplayWithStuart();\n```\n\n<br/> \nstuart 객체의 메서드를 변수에 할당한 후 호출하면 어떻게 될까요? \n<br/>\n<PostImage src=\"https://drive.google.com/uc?export=view&id=1XNmj00rT-zqfRCNY2Mml13-MeYMtHN2o\" alt=\"메서드를 변수에 저장하고 호출하면 this는 전역객체\" width=\"356\" height=\"44\" caption=\"this는 전역객체\"/>\n<br/>\n이 경우 일반 함수 호출이기 때문에 this에 전역객체가 바인딩되며 의도한대로 스튜어트와 놀 수 없게 됩니다.😢\n<br/> \n### 생성자 함수 호출\n<br/> \n```javascript\nfunction Minion(name,character) {        \n \tthis.name = name;\n  this.character = character;        \n \tthis.nickName = `${this.character} ${this.name}`;        \n \tthis.introduce = function () {   \n    function getName () {\n      return this.name;\n    }       \n \t\tconsole.log(`Bello! Me ${getName()}!`);        \n \t};        \n \tthis.printThis = function () {          \n \t\tconsole.log(this);       \n  }; \n}\n\nconst dave = new Minion(\"데이브\", \"엉뚱한\");\ndave.printThis();\n```\n<br/>\n<PostImage src=\"https://drive.google.com/uc?export=view&id=1O6kUri5HZNZq0eKrpDAzKs2nGY2b68Gv\" alt=\"메서드를 변수에 저장하고 호출하면 this는 전역객체\" width=\"600\" height=\"105\"/>\n<br/> \n생성자 함수 호출을 통해 인스턴스가 생성되면 생성된 인스턴스가 this에 바인딩 됩니다.\n<br/> \n```javascript\nfunction Minion(name,character) {        \n \tthis.name = name;\n  this.character = character;        \n \tthis.nickName = `${this.character} ${this.name}`;        \n \tthis.introduce = function () {   \n \t\tconsole.log(`Bello! Me ${this.name}!`);        \n \t};        \n \tthis.printThis = function () {          \n \t\tconsole.log(this);       \n  }; \n}\n\nconst dave = new Minion(\"데이브\", \"엉뚱한\");\nconst mel = new Minion(\"멜\", \"똑똑한\");\n\ndave.introduce = mel.introduce;\ndave.introduce();// Bello! Me 데이브!\n```\n<br/> \nMinion 생성자 함수를 통해 dave와 mel 인스턴스를 만들었습니다. 이 때 생성자 함수가 호출되었으니 this는 dave와 mel 객체를 각각 가리키고 있을 것입니다.\n이 상태에서 dave.introduce에 mel.introduce를 할당하고 dave.introduce를 호출하면 어떻게 될까요?\n이때도 역시 introduce 메서드를 호출한 주체인 dave 객체가 this가 되어 “Bello! Me 데이브!”가 출력됩니다.\n<br/> \n```javascript\nfunction sayHello(introduce){\n\tintroduce();\n}\n\nsayHello(dave.introduce);\n```\n<br/>\n<PostImage src=\"https://drive.google.com/uc?export=view&id=1fBI_8F1ciDXDVDKn37z_YLOP0babeppR\" alt=\"메서드를 콜백함수로 전달해서 호출하면 this는 전역객체\" width=\"294\" height=\"44\" caption=\"this가 전역 객체이기 때문에 제대로 출력이 되지 않고 있습니다.\"/> \n<br/>\n또한 이렇게 dave.introduce를 콜백함수로 넘겨 일반 함수로 호출하게 되면 dave.introduce의 this는 전역 객체가 됩니다.\n<br/> \n### 이벤트 리스너 함수 호출 \n<br/>\nthis는 리스너 함수의 두번째 인자로 오는 콜백함수의 형태에 따라 달라집니다.\n<br/> \n#### - function 키워드를 사용한 경우\n<br/>\n이벤트 리스너가 바인딩된 DOM 요소. event.currentTarget과 동일합니다.\n<br/> \n```javascript\nconst button = document.querySelector(\"button\");\n\nfunction handleButtonClick(event) {\n  console.log(this); // button\n  console.log(this === event.currentTarget) // true\n}\n\nbutton.addEventListener(\"click\", handleButtonClick);\n```\n<br/> \n#### - 화살표 함수를 사용한 경우\n<br/>\n화살표 함수의 상위 스코프의 this, 아래 코드에서는 상위 스코프가 전역이므로 전역객체가 this가 됩니다. \n따라서 화살표 함수에서는 this를 사용하기 보다 event 객체의 currentTarget을 사용하면 됩니다.\n<br/> \n```javascript\nconst button = document.querySelector(\"button\");\n   \nconst handleButtonClick = (event) => {\n  console.log(this); //Window 객체\n};\n\nbutton.addEventListener(\"click\", handleButtonClick);\n```\n<br/> \n## this 정적 바인딩하기\n<br/> \n앞서 살펴보았듯 함수 호출 방식에 따라 this가 동적으로 결정되기 때문에 개발을 하다보면 종종 예상치 못한 에러를 만나게 되는데요. 혼란스럽지 않게 this를 정적으로 바인딩하려면 어떻게 해야할까요?\n<br/> \n### apply, call, bind\ncall, apply, bind는 자바스크립트에서 함수의 this를 **명시적으로 설정할 수 있는 메서드**입니다.\n<br/> \n#### - call\ncall은 함수를 호출하면서 this 값을 명시적으로 지정할 수 있게 해줍니다. call의 첫 번째 인자에는 this로 지정하고 싶은 객체를 전달하며, 그 다음 인자들은 함수의 매개변수로 전달됩니다.\n<br/>\n```javascript\nfunction intoduce(arg1, arg2) {\n  console.log(`Bello! Me ${this.name}!`);\n}\n\nconst kevin = { name: '케빈' };\n\nintoduce.call(kevin, \"arg1\", \"arg2\"); // Bello! Me 케빈!\n```\n<br/>\n#### - apply \napply 또한 함수를 호출하며 this 값을 지정합니다. call과의 차이점은 두번째 인자인 함수의 매개변수를 배열로 전달해야합니다.\n<br/>\n```javascript\nfunction intoduce(arg1, arg2) {\n  console.log(`Bello! Me ${this.name}!`);\n}\n\nconst kevin = { name: '케빈' };\n\nintoduce.apply(kevin, [\"arg1\", \"arg2\"]); // Bello! Me 케빈!\n```\n<br/>\n#### - bind\nbind 메서드는 this 값을 고정한 새로운 함수를 반환합니다. call과 apply와는 달리 bind는 함수를 즉시 호출하지 않고, 나중에 호출할 수 있는 새로운 함수를 만듭니다. bind의 첫 번째 인자는 this로 지정할 객체를 전달하고 두번째 인자부터 함수의 매개변수를 전달합니다.\n<br/>\n```javascript\nfunction Minion(name,character) {        \n \tthis.name = name;\n  this.character = character;        \n \tthis.nickName = `${this.character} ${this.name}`;        \n \tthis.introduce = function () {   \n \t\tconsole.log(`Bello! Me ${this.name}!`);        \n \t};  \n  this.introduce = this.introduce.bind(this)      \n \tthis.printThis = function () {          \n \t\tconsole.log(this);       \n  }; \n}\n\nconst kevin = new Minion(\"케빈\", \"용감한\");\nconst stuart = new Minion(\"스튜어트\", \"기타치는\");\n\nkevin.introduce = stuart.introduce;\nkevin.introduce(); // Bello! Me 스튜어트!\n```\n<br/>\nintroduce 메서드에 this가 처음 바인딩 될 때의 this를 명시적으로 고정시켰기 때문에 이제 kevin.introduce를 호출해도 this는 stuart 인스턴스가 됩니다.\n그럼 아까 메서드에서 일반 함수를 호출 했을때 this가 전역객체가 되던 현상을 수정해보겠습니다.\n<br/>\n```javascript\nfunction Minion(name,character) {        \n \tthis.name = name;\n  this.character = character;        \n \tthis.nickName = `${this.character} ${this.name}`;        \n \tthis.introduce = function () {   \n    function getName () {\n      return this.name;\n    }\n    const getBoundingName = getName.bind(this);      \n \t\tconsole.log(`Bello! Me ${getBoundingName()}!`);        \n \t};        \n \tthis.printThis = function () {          \n \t\tconsole.log(this);       \n  }; \n}\n\nconst stuart  = new Minion('스튜어트', \"기타치는\");\nconst introduce = stuart.introduce(); // Bello! Me 스튜어트!\n```\n<br/>\ngetName 함수에 bind로 this를 명시적으로 연결하니 this가 잘 출력됩니다.🥳\n<br/>\n### 화살표 함수\n<br/>\n위 세가지 메서드를 사용하여 this를 정적 바인딩할 수도 있지만 조금 번거롭게 느껴집니다. 이 때 화살표 함수를 사용하면 더 깔끔하게 this를 정적으로 바인딩할 수 있습니다. \n화살표 함수에서의 this는 선언 시점의 상위 스코프의 this를 가리킵니다. 그 이유는 자바스크립트의 스코프체인 때문인데요. 화살표 함수에는 this가 존재하지 않기 때문에 선언 시점의 상위 스코프의 this를 참조하게 됩니다.\n<br/>\n```javascript\nfunction Minion(name,character) {        \n \tthis.name = name;\n  this.character = character;        \n \tthis.nickName = `${this.character} ${this.name}`;        \n \tthis.introduce = () => {        \n \t\tconsole.log(`Bello! Me ${this.name}!`);        \n \t};        \n \tthis.printThis = function () {          \n \t\tconsole.log(this);       \n  }; \n}\n\nconst dave = new Minion(\"데이브\", \"엉뚱한\");\nconst mel = new Minion(\"멜\", \"똑똑한\");\n\ndave.introduce = mel.introduce;\ndave.introduce(); // Bello! Me 멜!\n```\n<br/>\n메서드를 호출한 주체가 dave여도 화살표 함수를 선언했을 당시의 this인 mel 인스턴스가 this가 되는 것을 확인할 수 있습니다.\nbind 메서드를 사용할 때 보다 코드도 깔끔해졌습니다.\n<br/>\n```javascript\nfunction Minion(name,character) {        \n \tthis.name = name;\n  this.character = character;        \n \tthis.nickName = `${this.character} ${this.name}`;        \n \tthis.introduce = () => {   \n    const getName = () => {\n      return this.name;\n    }    \n \t\tconsole.log(`Bello! Me ${getName()}!`);        \n \t};        \n \tthis.printThis = function () {          \n \t\tconsole.log(this);       \n  }; \n}\n\nconst stuart  = new Minion('스튜어트', \"기타치는\");\nconst introduce = stuart.introduce(); // Bello! Me 스튜어트!\n```\n<br/>\n마찬가지로 getName 함수를 화살표 함수로 변경하니 this를 잘 가리키고 있습니다.\n<br/>\n<Callout icon=\"🤔\" title=\"왜 선언 시점에 this가 결정될까요?\">\n스코프 체인은 실행 컨텍스트의 LexicalEnvironment(렉시컬 환경)의 OuterEnvironmentReference (외부 환경 참조)에 의해 발생하는데요. 실행 컨텍스트가 함수 실행 전에 생성되니까 화살표 함수의 this도 함수 실행 전에 바인딩 되는 것 아닌가? 라고 생각이 들지도 모르겠습니다.(~~저만 그랬나요?~~ 🥸) 실행 컨텍스트는 함수 실행 전에 생성 되는 것이 맞지만 LexicalEnvironment는 코드가 어디에서 정의되었는지에 따라 결정되기 때문에 함수가 선언될 때의 위치에 따라 상위 스코프가 결정되게 됩니다. 그렇기에 화살표 함수의 this는 선언 시점의 상위 스코프의 this로 결정되는 것이죠.\n</Callout>\n<br/>\n<Callout icon=\"🚨\" title=\"객체에서 메서드를 정의할 때 화살표 함수를 사용하면 안되는 이유\">\n객체 리터럴은 실행 컨텍스트를 생성하지 않기 때문에 전역에서의 this 즉, 전역 객체가 바인딩 됩니다. 때문에 앞서 언급했듯 객체 리터럴을 통해 메서드를 정의 할때는 객체 메서드 축약 표현를 사용하는 것이 좋습니다.\n</Callout>\n<br/>\n## 포스팅을 마치며\n<br/>\n오늘은 자바스크립트에서의 this 바인딩에 대해 이야기 해보았는데요. 복잡한 내용 같았지만 핵심은 ‘this를 정적 바인딩 하지 않은 경우 메서드 호출 주체가 this가 된다’ 라고 이해하시면 좋을 것 같습니다. 긴 글 읽어주셔서 감사드리고 이만 글을 마치도록 하겠습니다.👋👋  \n<br/>","title":"this 바인딩 알아보기","intro":"자바스크립트에서 this를 사용해보신 적이 있으신가요? 아마 생각과 다른 값이 나와 당황스러우셨던 적도 있을 것 같은데요. 자바스크립트에서 this는 함수 호출 방식에 따라 값이 동적으로 바인딩 되기 때문에 이에 대해 잘 알아두지 않으면 함정에 빠지게 되는 경우가 종종 있습니다. this 바인딩에 대해 정리해보며 함정을 슉슉 피할 수 있는 슈퍼 개발자가 되어보겠습니다.","isFeatured":true,"createdAt":"2024-08-08","thumbnail":"https://drive.google.com/uc?export=view&id=1SKIK-J9lzuVqUZEZXkvbAX09u5z4B5OT","keywords":"자바스크립트, javascript, this, this 바인딩, this binding, arrow function, call, apply, bind"},{"categoryId":"1","categoryName":"Javascript","slug":"프로토타입(ProtoType)이란","content":"<p>{intro}</p>\n<Spacing size=\"lg\" />\n\n## 프로토타입이란?\n<br/>\n 사전적 의미의 프로토타입은 원래의 형태 또는 전형적인 예, 기초 또는 표준입니다. 원래의 형태, 즉 원형에 주목하여 자바스크립트에서의 프로토타입을 정의하면 **특정 객체의 원형이 되는 부모 객체**라고 할 수 있습니다. 자바스크립트에서 대부분의 객체는 원형 객체, 즉 프로토타입을 가지게 되며 프로토타입에 있는 프로퍼티와 메서드를 상속 받아 사용할 수 있게 됩니다.\n<br/>\n```javascript\nconst obj = {};\n\nconsole.log(obj)\n\nconsole.log(obj.[[Prototype]]);\n// SyntaxError: Unexpected token '['\nconsole.log(Object.getPrototypeOf(obj))\n```\n<br/>\n<PostImage src=\"https://drive.google.com/uc?export=view&id=1rxr4x95OyzOjQky0mx6QH4HSLJt6xDR6\" alt=\"obj의 프로토타입\" width=\"400\" height=\"263\" />\n<br/>\n객체 리터럴을 통해 빈 객체 obj를 만들고 콘솔을 통해 확인해보면 [[prototype]]에 Object 프로토타입이 존재하는 것을 확인할 수 있습니다. 또한 프로토타입에 정의된 메서드를 사용할 수도 있죠.\n<br/>\n다만 직접 프로토타입에 접근하려고 할 때 obj.[[Prototype]]으로는 접근할 수 없고 Object.getPrototypeOf() 메서드를 사용하여 객체의 프로토타입에 접근할 수 있습니다. \n<br/>\n\n<br/>\n## 프로토타입을 사용하는 이유\n<br/>\n**자바스크립트는 객체 지향 프로그래밍 언어**입니다. 객체 지향 프로그래밍이란 데이터를 객체 단위로 묶고, 객체 간의 상호작용을 통해 프로그램을 구성하는 방식을 말하는데요. \n객체 지향 프로그래밍의 특징으로는 **각 객체 간의 공통된 속성(프로퍼티)과 기능(메서드)을 추려 정의**하는 <HighlightText type=\"background\" fontWeight={700}>추상화</HighlightText>가 있습니다.\n<br/>\n아이돌 그룹 에스파를 예로 들어볼까요? (사심 1000%)\n<br/>\n에스파 각 멤버들의 공통된 속성을 떠올려봅시다. 멤버들은 이름, 포지션(메인보컬, 메인 댄서…)과 같은 속성(프로퍼티)을 가지고 있을 것이고 랩, 댄스, 노래와 같은 공통된 기능(메서드)을 수행합니다. 이렇게 공통된 특징을 추리고 정의하는 것을 추상화라고 합니다.  \n<br/>\n```javascript\nfunction Idol(name, role) { \n// 각 멤버들의 공통된 속성과 기능을 정의 (추상화)\n\tthis.name = name;\n    this.role = role;\n    this.rap = () => {\n\t\tconsole.log(`${this.name}이(가) 랩을 한다.`);\n    };\n    this.dance = () => {\n\t    console.log(`${this.name}이(가) 춤을 춘다.`);\n    };\n    this.sing = () => {\n\t    console.log(`${this.name}이(가) 노래를 한다.`);\n    };\n}\n\n// Idol 생성자 함수를 통해 멤버(instance) 생성\nconst karina = new Idol(\"카리나\", \"메인 댄서\"); \nconst winter = new Idol(\"윈터\", \"메인 보컬\");\nconst ningning = new Idol(\"닝닝\", \"리드 보컬\");\nconst giselle = new Idol(\"지젤\", \"메인 랩퍼\");\n\nconsole.log(karina);\nconsole.log(winter);\nconsole.log(ningning);\nconsole.log(giselle);\n\n```\n<br/>\n<PostImage src=\"https://drive.google.com/uc?export=view&id=15Y3Ftl1Ka_r0jI3BEx7tEThXU107Yhmk\" alt=\"프로토타입 체이닝\" width=\"400\" height=\"449\"/>\n<br/>\n이렇게 각 멤버들의 공통된 프로퍼티와 메서드를 추상화하여 Idol 생성자 함수를 만들고 생성자 함수를 통해 멤버(인스턴스)들을 만들 수 있게 되었습니다. \n<br/>\n그런데 name과 role처럼 인스턴스마다 고유한 값을 가지는 경우가 아닌 항상 동일한 기능을 수행하는 rap, dance, sing을 살펴봅시다. 완전히 같은 기능을 수행하는 메서드가 각 인스턴스 마다 포함되어 있는데요. 이렇게 되면 생성자 함수를 통해 만들어진 인스턴스의 수만큼 같은 코드가 중복으로 생성되게 됩니다. 실제로 각 메서드는 완전히 동일하지만 각각 중복으로 메모리에 저장되어있기 때문에 값을 비교하면 false가 나오게 되는 것을 알 수 있습니다.\n<br/>\n ```javascript\nconsole.log(karina.dance === winter.dance); // false\n```\n<br/>\n이처럼 인스턴스가 생성될 때마다 같은 코드가 중복으로 생성되어 메모리에 저장된다면 프로그램의 성능이 저하될 수 있겠죠.\n<br/>\n이런 불필요한 중복 방지를 위해 필요한 것이 바로 <HighlightText type=\"background\" fontWeight={700}>상속</HighlightText>입니다. 상속이란 **특정 객체의 속성이나 프로퍼티를 다른 객체가 그대로 이어받아 사용할 수 있는 것**을 말합니다. 그리고 자바스크립트는 바로 프로토타입을 사용하여 상속을 구현합니다.\n<br/>\n```javascript\nfunction Idol(name, role) {\n\tthis.name = name;\n    this.role = role;\n}\n\nIdol.prototype.rap = () => {\n    console.log(`${this.name}이(가) 랩을 한다.`);\n};\nIdol.prototype.dance = () => {\n\tconsole.log(`${this.name}이(가) 춤을 춘다.`);\n};\nIdol.prototype.sing = () => {\n\tconsole.log(`${this.name}이(가) 노래를 한다.`);\n};\n\nconst karina = new Idol(\"카리나\", \"메인 댄서\"); \nconst winter = new Idol(\"윈터\", \"메인 보컬\");\n\nconsole.log(karina.dance === winter.dance); //true\n```\n<br/>\n생성자 함수를 통해 생성된 인스턴스는 해당 생성자 함수의 prototype 프로퍼티를 프로토타입으로 가지는데요.\n(저는 예전에 karina의 프로토타입이 Idol이라고 착각한 적이 있는데 Idol은 생성자함수인 것이고 Idol.prototype이 karina의 프로토타입이 됩니다.)\n<br/>\n위와 같이 Idol.prototype을 통해 공통된 메서드를 정의하게 된다면 이제 모든 인스턴스들은 프로토타입에 정의된 메서드를 상속받아 사용할 수 있게 되고 더이상 여러번의 불필요한 코드 중복을 발생시키지 않게 됩니다. karina.dance와 winter.dance를 비교해도 true가 나오는 것을 알 수가 있습니다.\n<br/>\n이처럼 프로토타입은 자바스크립트의 객체 지향 프로그래밍에서 상속을 구현할 수 있게 하며 자바스크립트가 프로토타입 기반의 객체 지향 언어라고 불리는 이유이기도 합니다.\n<br/>\n## 상속 구현하기\n<br/>\n이제 우리는 프로토타입이 무엇인지 프로토타입을 왜 사용하는지에 대해 알게 되었습니다. \n그럼 이제 프로토타입을 이용하여 상속을 구현해봅시다.\n<br/>\n```javascript\nfunction Singer(name){\n\tthis.name = name;\n}\n      \nSinger.prototype.sing = function () {\n\tconsole.log(`${this.name}이(가) 노래를 한다.`);\n};\n\nfunction Idol(name, role) {\n  Singer.call(this, name); // Singer 생성자 함수를 호출\n\tthis.role = role;\n}\n\nIdol.prototype = Object.create(Singer.prototype); // prototype 연결\n\nIdol.prototype.rap = function () {\n\tconsole.log(`${this.name}이(가) 랩을 한다.`);\n};\n\nIdol.prototype.dance = function () {\n\tconsole.log(`${this.name}이(가) 춤을 춘다.`);\n};\n\nconst karina = new Idol(\"카리나\", \"메인 댄서\");\n\nkarina.dance();\n\n```\n<br/>\n1. Object.create('Signer.prototype') 을 사용하여 새 객체를 생성합니다. 이때 첫번째 인자에 들어가는 값이 생성되는 객체의 프로토타입이 됩니다. \n즉 Idol.prototype은 Singer.prototype을 프로토타입으로 갖게 됩니다. (프로토타입탈트 붕괴..)\n2. Idol 생성자 함수에서 Singer 함수를 호출합니다. 이때 call 메서드를 사용하여 this와 인자값을 전달합니다.\n<br/>\n이제 Singer.prototype을 상속받아 karina.sing()를 호출할 수 있습니다!\n<br/>\n## 프로토타입 체이닝\n<br/>\n위 예제에서 karina 객체 내부에 dance 메서드가 없어도 실행시킬 수 있었는데요. 이는 객체에서 프로퍼티를 찾을 때 객체 내부에 해당 프로퍼티가 없다면 그 객체의 프로토타입을 확인하며 계속 위로 올라가면서 찾는 과정인 프로토타입 체이닝이 있기 때문입니다. 이를 통해 자바스크립트는 상속을 구현하게 됩니다. 그리고 프로토타입 체이닝의 끝에는 최상위 프로토타입인 Object.prototype이 있습니다. 즉 거의 모든 자바스크립트 객체는 Object.prototype를 상속 받게 됩니다.\n(맨 처음 프로토타입을 정의할 때 예시코드에서도 빈 객체인 user에 Object 프로토타입이 있었죠?)\n<br/>\n## 상속 확인 하기\n<br/>\n이렇게 상속이 이어지다 보면 특정 인스턴스가 어떤 생성자 함수를 통해 만들어졌는지 헷갈릴 수도 있을텐데요. 이럴때는 instandeOf 연산자를 사용하여 확인하면 됩니다. 인스턴스 instanceof 생성자 생성자 함수를 통해 생성된 인스턴스이면 true, 아니라면 false를 리턴합니다.\n<br/>\n```javascript\nconsole.log(karina instanceof Singer)// true;\nconsole.log(karina instanceof Idol) //true;\nconsole.log(karina instanceof Actor) //false\n```\n<br/>\n## 오버라이딩\n<br/>\n같은 프로토타입을 공유하고 있는 객체 중 하나의 객체에서만 프로퍼티나 메서드를 수정하고 싶을 땐 어떻게 해야할까요? 이를 위해 프로토타입에 정의된 메서드를 하위 객체에서 재정의하는 오버라이딩에 대해 알아봅시다.\n<br/>\n에스파의 메인보컬인 닝닝은 주로 고음을 담당합니다. 닝닝의 sing 메서드를 수정해봅시다.\n<br/>\n```javascript\nningning.sing = ()=>{\n\tconsole.log(`${this.name}은(는) 고음을 부른다.`);\n}\n\nningning.sing(); //닝닝은(는) 고음을 부른다.\ngiselle.sing(); //지젤이(가) 노래를 부른다.\n\n```\n<br/>\nningning.sing을 재정의하여 ningning.sing이 오버라이딩 되었습니다. 하지만 giselle.sing은 기존의 메서드를 유지하고 있죠. \n<br/>\n<PostImage src=\"https://drive.google.com/uc?export=view&id=1Tn8U4kWBrZno1r4QlFeG00n1z1m68DEc\" alt=\"Idol의 instance\" width=\"400\" height=\"177\"/>\n<br/>\n이것은 ningning.sing을 오버라이딩 할 때 프로토타입의 메서드를 수정한 것이 아니라 ningning 인스턴스에 메서드로 추가된 것이기 때문입니다. 이처럼 인스턴스 프로퍼티(프로퍼티와 메서드를 모두 포함)에 의해 프로토타입 프로퍼티가 가려지는 현상을 프로퍼티 섀도잉이라고 합니다.\n<br/>\n## 포스팅을 마치며\n<br/>\n여기까지 프로토타입의 의미, 왜 프로토타입이 사용되는지, 프로토타입을 통한 상속 구현에 대해 알아보았습니다. (더 상세한 내용을 알고 싶으시다면 자바스크립트 딥다이브 책을 추천드려요. 무려 50 페이지에 걸친 방대한 내용이 여러분을 기다리고 있습니다.) \n<br/>\n사실 요즘에는 Class 문법을 사용하는 추세지만 그래도 그 근간에는 프로토타입이 있기 때문에 자바스크립트를 사용하는 개발자라면 프로토타입에 대해 알아두는 것이 중요할 것 같습니다.\n<br/>\n포스팅 시작 전에 말했듯 프로토타입에 대해 어렴풋이 알고 있었지만 말로 설명하기가 어려웠는데요. 일단 프로토타입에 대해 완전히 이해하지 못한 상태였고 또 너무 방대한 내용이여서 어디부터 어디까지 이야기 해야할지 몰랐던 것 같기도 합니다. 하지만 이번 기회를 통해 프로토타입에 대해 명확히 알 수 있었고 자바스크립트 상속 매커니즘을 엿볼 수 있어서 재밌었습니다. 가끔 인스턴스, 프로토타입탈트 붕괴 현상이 찾아오긴 했지만.. 글을 읽으시는 분들도 많이 헷갈리실 것 같아서 걱정이 듭니다. 긴 글 읽어주셔서 감..사건은 다가와 Oh Eh 👻\n","title":"프로토타입(ProtoType)이란","intro":"예전에 같이 일하던 프론트엔드 개발자님께 ‘프로토타입이 뭔지 아시나요?’란 질문을 받은 적이 있는데요. 머리 속에 둥둥 떠오르는 내용들을 말로 설명하기 어려웠던 기억이 납니다. 공부를 하다보면 강의를 듣거나 문서를 읽은 것만으로 이해했다고 착각하기 쉬운 것 같습니다. 머리로 어렴풋하게 알고 있는 것과 실제로 다른 사람에게 말로 설명하는 것에는 아주 큰 차이가 있는데 말이죠. 오늘은 제가 알고 있다고 착각했던 프로토타입에 대해 정리해보겠습니다.","isFeatured":true,"createdAt":"2024-08-02","thumbnail":"https://drive.google.com/uc?export=view&id=1c0_ly-NQ_bRsw2up4RqKkFfETN_97aJF","keywords":"자바스크립트, javascript, 프로토타입, prototype, 객체 지향, 상속"},{"categoryId":"1","categoryName":"Javascript","slug":"원시형과-객체형","content":"<p>{intro}</p>\n<Spacing size=\"lg\" />\n\n## 원시 타입 (Primitive Type)\n<br/>\n- 원시타입에는 총 6가지의 데이터 타입이 있습니다. (아래 표 참고)\n- 변수에 **실제 값이 직접 저장**되는 데이터 타입입니다.\n- **불변한(immutable)** 값이며 재할당 시 기존 메모리 공간을 덮어 쓰는 것이 아니라 새로운 메모리 공간에 값을 저장하고 식별자는 새로운 메모리 주소를 가리키게 됩니다.\n- 원시 값을 갖는 변수를 다른 변수에 복사하면 원본의 **값 자체가 복사**됩니다.\n<br/>\n| 데이터 타입  | 예시 값 | 부연 설명 |\n| --- | --- | --- |\n| 문자열 (string) 타입  | ‘가나다’, ‘1234’ |  |\n| 숫자 (number) 타입  | 123, -123, infinite, NaN (Not a Number) | |\n| boolean 타입  | 논리 값, 참 (true)과 거짓 (false) | |\n| undefined 타입 | undefined (변수에 값이 할당되지 않았을 때 초기 값) |  |\n| null 타입 | null (’값이 없음’을 명시할 때 사용) |  typeof 사용 시 object가 나옴  |\n| symbol 타입 | 변경 불가능한 원시타입 값 | |\n<br/>\n<PostImage src=\"https://drive.google.com/uc?export=view&id=1SeVPcTnmDHVUgCGwWAcncEzvDP-kJsBt\" alt=\"원시형 데이터\" width=\"660\" height=\"795\"/>\n> 1. 실제 값 123456가 password 변수에 저장됩니다.\n> 2. password를 복사한 copyPassword는 password의 값 123456을 복사합니다.\n> 3. password에 654321로 값을 재할당하면 기존의 123456 값을 수정하는 것이 아니라 새로운 메모리 공간에 저장되며 password 식별자는 새로운 값이 담긴 메모리 주소를 가르킵니다.\n\n<br/>\n<Callout title=\"데이터 타입을 확인하고 싶을땐?\">\ntypeof 연산자를 사용하면 데이터 타입을 문자열로 반환합니다.\n</Callout> \n<br/>\n```javascript\nconsole.log(typeof true); // boolean\nconsole.log(typeof \"true\") //string\n```\n<br/>\n## 객체 타입 (Object Type)\n<br/>\n- 원시형 데이터가 아닌 모든 데이터 타입이 객체 타입 데이터입니다. (객체, 배열, 함수 등)\n- 객체 데이터는 **크기가 동적으로 바뀔 수 있기에 힙 메모리에 저장**되며 변수에는 **데이터의 메모리 주소가 저장**됩니다.\n- **변경 가능(mutable)**한 값이며 객체의 프로퍼티를 바꾸는 것이 가능합니다.\n- 객체 타입 변수를 다른 변수에 복사하면 원본의 **메모리 주소 값이 복사**됩니다.\n- 같은 주소를 바라보고 있기 때문에 **복사한 객체를 수정하면 원본 객체도 같이 수정됩니다.**\n<br/>\n<PostImage src=\"https://drive.google.com/uc?export=view&id=1PlT7EDKxpr3AAoqW9WGBHwYvJO8Ymkr3\" alt=\"\" width=\"660\" height=\"972\"/>\n<br/>\n> 1. userInfo는 객체가 저장된 주소를 저장합니다.\n> 2. copyUserInfo는 userInfo 객체가 저장된 주소 값을 복사합니다.\n> 3. 객체 타입 데이터는 변경 가능한 값이므로 프로퍼티를 바꾸는 것이 가능합니다. userInfo.name이 '김유저'에서 '이유저'로 변경\n> 4. userInfo와 copyUserInfo는 같은 객체를 참조하고 있기 때문에 userInfo.name도 '이유저'가 됩니다. \n\n<br/>\n<Callout title=\"배열은 무슨 타입일까?\">\narray는 배열이지만 데이터 타입은 **object**로 나오는 걸 볼 수 있습니다. 객체형 데이터 중 function만 예외적으로 **function** 타입을 반환합니다.\nArray.isArray() 메서드를 사용하여 배열인지 아닌지 확인할 수 있습니다.\n</Callout>\n\n<br/>\n```javascript\nconst array = [];\nconst func = function (){}\n\nconsole.log(typeof func) //function\nconsole.log(typeof array); // object\nconsole.log(Array.isArray(array)) //true\n\n```\n<br/>\n## 🚨객체형 데이터를 다룰 때 주의해야 할 점\n<br/>\n```javascript\nconst userInfo = {\n\tid: 1,\n\tname: \"김유저\",\n};\n\nconst copyUserInfo = userInfo;\n\ncopyUserInfo.name = \"이유저\"; // 복사한 객체에서 데이터 수정\n\nconsole.log(userInfo.name) // \"이유저\", 복사한 객체를 수정하였지만 원본 객체도 수정되었다!\n```\n<br/>\n위 코드 처럼 copyUserInfo를 수정하면 원본인 userInfo도 수정됩니다. **두 변수가 같은 메모리 주소를 바라보고 있기 때문입니다.** 원본을 수정하려고 의도한 것이 아니었다면 예기치 못한 에러가 날 수도 있겠죠. 때문에 객체형 데이터를 복사할 때는 원본 데이터에 영향을 미치지 않도록 **불변성을 유지하는 것이 중요합니다.**\n<br/>\n## 불변성을 유지하며 객체 타입 복사하기\n<br/>\n객체의 복사는 얕은 복사와 깊은 복사가 있습니다. <HighlightText type=\"background\" fontWeight={700}>얕은 복사</HighlightText>란 **복사 데이터의 속성이 원본 데이터와 같은 참조를 공유하는 경우**이고 <HighlightText type=\"background\" fontWeight={700}>깊은 복사</HighlightText>는 **원본 데이터와 공유하는 참조값이 없는 복사**로 원본 데이터의 불변성을 유지할 수 있습니다.\n<br/>\n### 얕은 복사(Shallow Copy)\n<br/>\n#### 1. spread 연산자 \n객체와 배열을 쉽게 복사할 수 있는 방법으로 spread 연산자(...)가 있습니다. spread 연산자를 사용하면 배열이나 객체를 펼쳐서 개별 요소로 분리할 수 있습니다. 사용하기도 쉽고 보기에도 간결하기 때문에 저는 많은 경우 spread 연산자를 사용하여 객체 데이터를 복사합니다.\n<br/>\n```javascript\nconst user = {\n\tid:123456,\n\taddress: \"우리 집\",\n};\nconst copyUser = {...user};\n\nconsole.log(user === copyUser) //false\n\n\nconst colors = [\"빨강\", \"주황\", \"노랑\"];\nconst copyColors = [...colors];\n\nconsole.log(colors === copyColors) //false\n```\n<br/>\nuser와 colors를 spread 연산자로 분리한 후 새로운 객체와 배열로 만들었습니다. 원본 데이터와 비교해보면 false가 나오는 걸 볼 수 있습니다.\n이제 복사 데이터를 변경해도 원본 데이터에 영향이 가지 않습니다.\n<br/>\n```javascript\nconst userList = [\n    {\n      id: 1,\n      name: \"김유저\",\n    },\n    {\n      id: 2,\n      name: \"이유저\",\n    },\n    {\n      id: 3,\n      name: \"박유저\",\n    },\n];\n\nconst copyUserList = [...userList];\nconsole.log(userList === copyUserList);// false\nconsole.log(userList[0] === copyUserList[0]); \n//true, 같은 메모리 주소를 가지고 있음, 불변성 보장 ❌\n```\n<br/>\n다만 spread 연산자는 얕은 복사를 하기 때문에 최상위 속성만 복사하며 중첩된 객체, 배열의 불변성을 보장하지 않습니다.\n<br/>\n#### 2. Object.asign()\nObject.assign()는 첫 번째 인자인 대상 객체에 두 번째 이후의 인자인 소스 객체들의 속성을 대상 객체에 복사하고 병합한 후 대상 객체를 반환하는 메서드입니다.\n이또한 얕은 복사이기에 중첩 객체 데이터의 불변성은 보장되지 않습니다.\n<br/>\n```javascript\nconst targetObj = {\n  a : 1,\n  b : 2\n}\nconst sourceObj = {\n  c : 3,\n  d : 4\n}\n\nconst assignedObj = Object.assign(targetObj,sourceObj); \n// targetObj에 sourceObj의 속성을 복사하고 병합한 후 targetObj가 반환\nconsole.log(assignedObj);\n// {\n//   a : 1,\n//   b : 2,\n//   c : 3,\n//   d : 4\n// }\nconsole.log(targetObj ===assignedObj) // true\n```\n<br/>\ntargetObj에 sourceObj의 속성을 복사한 후 병합할 수 있습니다.\n<br/>\n```javascript \nconst userInfo = { \n    id : 1,\n    name : \"김유저\"\n};\nconst copyUserInfo = Object.assign({},userInfo); \n//대상 객체 {}에 userInfo 객체의 속성을 복사하고 병합하여 대상 객체를 반환\n\nconsole.log(userInfo === copyUserInfo); // false\n```\n<br/>\n이런 식으로 얕은 복사를 할 수 있게 됩니다.\n<br/>\n#### 3. Array.from()\n<br/>\nArray.from()은 원본 배열을 얕게 복사한 새로운 배열을 반환합니다.\n```javascript\nconst userList = [\n    {\n      id: 1,\n      name: \"김유저\",\n    },\n    {\n      id: 2,\n      name: \"이유저\",\n    },\n    {\n      id: 3,\n      name: \"박유저\",\n    },\n];\nconst copyUserList = Array.from(userList);\nconsole.log(userList===copyUserList);//false\n\n```\n<br/>\n#### 4. 새로운 배열을 리턴하는 배열 메서드\n<br/>\n배열의 경우 map, filter, slice, concat, reduce 등 **새로운 배열을 리턴하는 배열 메서드**를 사용하여 얕은 복사가 가능합니다.\n대표적으로 많이 쓰이는 map의 경우를 살펴보겠습니다.\n<br/>\n```javascript\nconst userList = [\n    {\n      id: 1,\n      name: \"김유저\",\n    },\n    {\n      id: 2,\n      name: \"이유저\",\n    },\n    {\n      id: 3,\n      name: \"박유저\",\n    },\n];\nconst copyUserList = userList.map((userItem)=>({...userItem}));\nconsole.log(userList===copyUserList);//false\nconsole.log(userList[0] ===copyUserList[0])//false\n\n```\n<br/>\n배열 메서드도 얕은 복사를 하지만 callback 함수 안에서 userList의 원소인 userItem을 다시 한번 복사하는 것이 가능합니다.\n<br/>\n\n### 깊은 복사(Deep Copy)\n깊은 복사를 하기 위해서는 재귀함수를 사용하여 deepCopy 함수를 구현하거나 deepCopy 기능을 제공하는 라이브러리를 사용하시면 됩니다.\n(라고 Chat GPT가 알려줬습니다. 저는 프로젝트에서 깊은 복사를 해본 경험은 없네요😥) \n프로젝트에 따라 직접 구현 또는 관련 라이브러리 도입을 고민해보면 될 것 같습니다. 저는 공부 목적으로 깊은 복사를 직접 구현해보겠습니다.\n<br/>\n#### 1. deepCopy 함수 구현하기\n<br/>\n> **목표 : 데이터를 돌면서 프로퍼티 혹은 원소가 object 타입이 아닐때까지 재귀적으로 값을 얕은 복사하여 결과적으로 원본 데이터와의 참조 값을 완전히 끊어낸다.**\n> <br/>\n> 1. base case : 인자로 받아온 data의 타입을 체크한 한 후 object 타입이 아니라면 data를 리턴.\n> 2. data가 배열인 경우 : map을 사용하며 원소를 재귀적으로 복사 후 리턴.\n> 3. data가 object인 경우 : for in 반복문을 사용하여 속성을 재귀적으로 복사 후 result에 추가, result 리턴\n\n<br/>\n```javascript\nconst deepCopy = (data) => {\n  // null의 type이 object이므로 주의해서 조건에 추가.\n  if (data === null || typeof data !== \"object\") {\n    return data;\n  }\n  if (Array.isArray(data)) {\n    return data.map((item) => deepCopy(item));\n  }\n  const result = {};\n  for (key in data) {\n    result[key] = deepCopy(data[key]);\n  }\n  return result;\n};\n\nconst userList = [\n  {\n    name: \"김유저\",\n    address: {\n      country: \"한국\",\n      city: \"서울\",\n      coordinates: [126.978, 37.5665],\n    },\n    hobbies: [\"달리기\", \"책 읽기\"],\n  },\n  {\n    name: \"이유저\",\n    address: {\n      country: \"미국\",\n      city: \"워싱턴 DC\",\n      coordinates: [74.006, 40.7128],\n    },\n    hobbies: [\"게임하기\", \"등산\"],\n  },\n  {\n    name: \"박유저\",\n    address: {\n      country: \"일본\",\n      city: \"도쿄\",\n      coordinates: [35.6828, 139.7595],\n    },\n    hobbies: [\"영화보기\", \"테니스\"],\n  },\n];\n\nconst copiedUserList = deepCopy(userList);\nconsole.log(\n    userList[1].address.country[0] === copiedUserList[1].address.coordinates[0]\n  ); //false\n```\n재귀적으로 데이터를 얕은 복사하는 deepCopy 함수를 쓰니 배열안의 객체안의 배열의 값을 비교해도 false가 나옵니다 🎉\n<br/>\n(딴소리지만 재귀함수를 사용할 때는 재귀함수 종료 조건인 base case를 잘 설정해줍시다. \n조건을 data === null <HighlightText type=\"background\">&&</HighlightText> typeof data !== \"object\"로 넣었다가 눈물이 찔끔 나왔버렸습니다.)\n<PostImage src=\"https://drive.google.com/uc?export=view&id=1WC-1hkUU_hwYWNap9E6gD7F4FByIEtX-\" alt=\"스택오버플로우\" width=\"440\" height=\"177\"/>\n\n<br/>\n## 포스팅을 마치며\n<br/>\n오늘은 원시형 데이터와 객체형 데이터의 특징과 데이터의 불변성을 유지하는 방법에 대해 알아보았습니다. 처음 포스팅을 시작할 때도 이야기했듯이 자바스크립트를 처음 배울 때는 원시형 데이터와 객체형 데이터를 나누는 큰 특징보다는 원시형 데이터에 더 집중해서 공부했었습니다. 그러다 리액트를 접하게 되고 객체형 데이터의 특성을 이해하는 것이 중요하다는 것을 알게 되었습니다. 리액트는 state의 변화에 따라 화면을 리렌더링 하기 때문에 객체를 변경해도 주소 값이 같다면 리렌더링이 안 되는 이슈가 발생할 수 있었기 때문이죠. 따라서 원본 객체와 다른 주소 값을 가지는 새로운 객체를 만들어 원본 객체의 불변성을 유지할 필요가 있었습니다. (물론 리액트를 사용하지 않더라도 복사된 데이터에 의해 원본 데이터가 수정되지 않도록 불변성을 유지하는 것은 중요한 일입니다.) 이때 다시 한 번 느끼게 된 것은 어떤 라이브러리를 사용하더라도 자바스크립트의 특성을 알고 있는 것이 중요하다는 것이었습니다. 만약 객체형 데이터의 특성을 모른다면 리렌더링 이슈가 발생했을 때 왜 이런 이슈가 발생하는지 파악하기 힘들 테니까요. 그리고 빠르게 변화하는 프론트엔드 생태계 특성상 언제 어떤 라이브러리가 리액트의 자리를 대신하게 될지 모르지만 자바스크립트 지식이 탄탄하게 깔려 있다면 쉽게 적응할 수 있다고 생각합니다. 저도 아직 많이 배우는 단계이기에 그런 경지에 오르기 위해 많이 공부하고 노력해야될 것 같습니다. 여기까지 긴 글 읽어주셔서 감사드리고 앞으로도 꾸준히 공부하며 기록하도록 하겠습니다.🤓\n","title":"원시형과 객체형","intro":"자바스크립트에서 데이터는 크게 원시 타입, 객체 타입으로 구분됩니다. 데이터 타입에 대해 처음 배울 때는 원시형, 객체형의 특징 보다는 그 안에 포함된 각각의 타입에 더 집중해서 공부하였지만 실제로 프로젝트를 진행하면서 객체 타입 데이터의 특성 이해하는 것이 중요하다는 사실을 알게 되었습니다. 그렇기에 오늘은 원시 타입과 객체 타입의 특징과 함께 객체 타입 데이터를 다룰 때 조심해야 할 부분에 대해서 알아보도록 하겠습니다.","isFeatured":false,"createdAt":"2024-07-28","thumbnail":"https://drive.google.com/uc?export=view&id=12UVym-fm2t8p66hBEdPasA8RgGLkFqRw","keywords":"자바스크립트, javascript, data type, 원시형, 객체형, 불변성"},{"categoryId":"1","categoryName":"Javascript","slug":"var는-왜-더이상-사용되지-않을까","content":"<p>{intro}</p>\n<Spacing size=\"lg\" />\n\n## 프로그래밍에서 변수란?\n<br/>\n프로그래밍에서 변수란 **하나의 값을 저장하기 위해 이름이 붙은 메모리 공간**을 뜻합니다.\n<br/>\n```javascript \nvar password = 123456; \n```\n<br/>\n위와 같이 변수를 선언하고 값을 할당하면 3단계에 걸쳐 변수에 값이 저장됩니다.\n<br/>\n<PostImage src=\"https://drive.google.com/uc?export=view&id=1WtfApWevV7lzHhaKIx6mF-KktJy5wZBo\" alt=\"변수 선언 과정\" width=\"580\" height=\"392\"/>\n<br/>\n> 1. 선언 : 자바스크립트 엔진이 **변수의 식별자를 인식하는 단계**입니다. 식별자만 인식할 뿐 값이 저장되지는 않습니다.\n> 2. 초기화 : 변수 식별자가 인식된 후, **메모리 공간을 확보하고 초기값을 설정하는 단계**입니다. 이 때 식별자는 확보된 메모리 공간의 주소값을 가르킵니다. 초기 값이 명시되어 있지 않은 경우 undefined로 초기화 됩니다.\n> 3. 할당 : 식별자가 가르키고 있는 주소의 **메모리 공간에 값을 저장하는 단계**입니다.\n<br/>\n## var와 const, let의 차이\n<br/>\n이제 자바스크립트에서 변수를 선언할 때 사용하는 세가지 키워드 var와 const,let의 차이점에 대해 알아봅시다.\n<br/>\n### 1. 재선언 , 재할당 가능 여부\n<br/>\n#### 재선언과 재할당이란?\n<br/>\n**재선언** : 이미 선언된 변수 식별자를 다시 사용하여 변수를 선언하는 것을 의미합니다.\n<br/>\n```javascript \nvar password = 123456; \nvar password = 654321; // 이미 사용된 password 식별자를 사용하여 변수를 재선언\n\nconsole.log(654321); // 재선언 시 할당된 654321이 출력된다.\n```\n<br/>\n**재할당** : 변수에 값을 다시 할당하는 것을 의미합니다.\n<br/>\n```javascript \nvar password = 123456; \npassword = 654321; // password 값에 값을 재할당\n\nconsole.log(654321); // 재할당 된 654321 값이 출력된다.\n```\n<br/>\nvar와 const, let의 재선언, 재할당 여부는 아래와 같습니다.\n<br/>\n| 변수 선언 키워드| 재선언 | 재할당 |\n| ----------- | ------ | ------ |\n| var         | O      | O      |\n| const (ES6) | X      | X      |\n| let (ES6)   | X      | O      |\n<br/>\n1. **var** : 재선언과 재할당 **모두 가능**합니다.\n2. **const** : 재선언과 재할당 **모두 불가능**합니다. 값이 변하지 않으니, 선언과 동시에 값이 할당되어야 합니다. 재할당이 허용되지 않으므로 상수(constance)라고도 합니다.\n3. **let** : **재할당만 가능**하고 재선언은 허용되지 않습니다.\n<br/>\n<PostImage src=\"https://drive.google.com/uc?export=view&id=14fhjKXNkr4VFS8JnRq4UDa8c052BeEp9\" alt=\"챗지피티한테 let의 의미를 물어보았다.\" width=\"558\" height=\"266\" caption=\"그래서 let이 무슨 뜻이냐고요...\"/>\n<br/>\n#### 재선언의 위험성 🚨\n<br/>\n```javascript \nvar password = 123456; \n\n// 1000 lines later ...🐌\n\nvar password = 654321; \n// 코드가 너무 길어져 실수로 위에 선언된 password를 덮어쓴다면?!😱\n```\n<br/>\n위와 같이 코드가 길어지거나 다른 개발자와 협업하여 일하는 경우 기존에 변수가 재선언되어 덮어써진다면 생각지 못한 에러가 발생하겠죠? 이런 상황을 미연에 방지하기 위해 **재선언을 허용하지 않는 키워드인 const와 let을 사용하는 것이 좋습니다.**\n<br/>\n#### 어떤 상황에서 const를 쓰고 let을 써야할까요?🤔\n<br/>\n **변수에 값을 재할당해야 할 이유가 없는 모든 경우에 const를 쓰는 것이 바람직합니다.** const는 재할당조차 허용하지 않는 가장 엄격한 키워드이기 때문에 의도치 않게 값을 변경시키는 일이 발생하지 않기 때문입니다.\n<br/>\n```javascript\nconst password = 123456; \n\npassword = 654321; \n// TypeError: Assignment to constant variable\n```\n<br/>\n 부득이하게 값이 재할당 되어야 할 때는 let을 사용하면 됩니다. 저는 주로 if문, switch문 같은 조건문에서 조건에 따라 값을 다르게 할당해야하는 경우에 사용했습니다. \n (~~만약문이라고 쓰고 5초간 뭐가 이상한지 몰랐던 사람이 바로 저예요~~)\n<br/>\n### 2. 스코프 (scope)\n<br/>\n#### 스코프란?\n<br/>\n스코프(scope)는 **변수에 접근할 수 있는 유효 범위**를 뜻합니다.<br/>\n<br/>\n**전역 스코프 (Global Scope)** : 함수나 블럭 바깥의 최상위 공간입니다. 전역 스코프에 선언된 변수는 어디서나 접근 가능하며 이를 전역 변수라고 합니다.\n**지역 스코프 (Local Scope)** : 함수나 블럭 내부를 뜻합니다. 지역 스코프에 선언된 변수는 해당 스코프 내에서만 접근 가능하여 이를 지역 변수라고 합니다.\n<br/>\n<PostImage src=\"https://drive.google.com/uc?export=view&id=1ZAsj37PaM6f7rCxrv65DjyHeVz4BMqy_\" alt=\"스코프\" width=\"558\" height=\"266\"/>\n<br/>\n>1. 전역 스코프에 선언된 변수는 어디서나 접근 가능합니다.\n>2. 지역 스코프에 선언된 변수는 전역 스코프에서 접근할 수 없습니다.\n  <br/> (전역 스코프에서 outerFunction에 선언된 outerVar에 접근할 수 없음)\n>3. 함수가 중첩된 경우 하위 함수에서는 상위 함수에 선언된 변수에 접근할 수 있지만 외부 함수에서 내부 함수에 선언된 변수에 접근할 수 없습니다.\n  <br/> (outerFunction에서 innerFunction에 선언된 innerVar에 접근할 수 없음)\n>4. 변수에 접근할 때 함수 내부에 선언되지 않았다면 상위 스코프로 올라가서 찾습니다. (스코프 체인)\n  <br/> (innerFunction은 outerFunction, 전역 스코프에 있는 변수에 모두 접근이 가능)\n\n<br/>\n#### var와 const, let의 스코프 차이\n<br/>\n- **var의 스코프** : **함수 레벨** (function level)\n- **const, let의 스코프** : **블럭 레벨** (block level)\n<br/>\n#### 함수 스코프의 단점\n<br/>\n함수 선언 시에 블럭이 사용되니 둘이 비슷한 것이 아닌가? 라는 생각이 들수도 있지만 함수 레벨의 유효 범위에서는 if문, for문처럼 함수가 아닌 문(statement) 안에서 선언한 변수가 전역변수가 되어 코드 여기저기서 참조할 수 있게 될뿐더러 다른 변수와 충돌할 가능성이 있습니다. 때문에 **안정적이고 예측 가능한 변수 사용을 위해 블록 스코프인 const와 let을 사용하는 것이 좋습니다.**\n<br/>\n```javascript\nfor (var i = 0; i < 10; i++) {\n  var a = \"a\";\n}\nconsole.log(i); // 10 => 루프 헤더에 선언된 i에 접근 가능\nconsole.log(a); // 'a' => for문 안에 선언된 a에도 접근 가능\n\nif (false) {\n  var b = \"b\";\n}\n\nconsole.log(b); \n// undefined => if문의 조건이 거짓이므로 값을 할당되지 않았지만 전역변수이기에 접근은 가능하다🙄\n``` \n<br/>\n### 3. 호이스팅 (Hoisting) 현상\n<br/>\n<Callout>\n자바스크립트는 런타임 환경에서 코드를 한 줄 한 줄 읽어내려가는 인터프리터 언어이다.\n</Callout>\n<br/>\n자바스트립트를 공부하면 제일 처음 배우게 되는 자바스크립트의 특징입니다. ~~(근데 이제 공부할 수록 가장 큰 혼란을 주는)~~\n위의 자바스크립트의 특징을 잘 기억해둔 후 아래 코드를 살펴봅시다.\n<br/>\n```javascript\nconsole.log(password); //undefined\n\nvar password = 123456;\n```\n<br/>\n위 코드는 에러가 나야할 것 같지만 undefined가 출력될 뿐 에러 없이 코드가 돌아갑니다. (~~어째서..~~ 🤦)\n<br/>\n이는 “끌어올리다”라는 뜻을 가진 <HighlightText type=\"background\" fontWeight={700}>호이스팅</HighlightText>으로 인해 나타나는 현상으로 자바스크립트 엔진이 코드를 실행 하기 전에 **코드의 변수, 함수, 클래스의 선언부를 스코프의 최상단으로 끌어올리는 것처럼 동작하는 현상**을 말합니다. \n(함수 선언문 위에서 함수 실행이 가능한 이유도 호이스팅 때문이죠.)\n<br/>\nvar의 경우 호이스팅 시 **선언과 동시에 undefined로 초기화**되기 때문에 변수 선언문 이전에 변수를 참조해도 에러 없이 undefined 값을 얻을 수 있게 됩니다.\n<br/>\n#### var의 호이스팅\n<br/>\n![var의 호이스팅](https://drive.google.com/uc?export=view&id=1Fp1-ZFQeIhvim7xyAgEHu-O6iagpDqjA)\n<br/>\n> 1. 초기화 된 undefined 출력 😱\n> 2. 선언 후 값을 할당하지 않았으므로 undefined로 초기화\n> 3. undefined 출력\n> 4. 123456 할당\n> 5. 123456 출력\n\n<br/>\n그럼 const와 let은 어떨까요?\n<br/>\n<Callout icon=\"🚨\">\n  <HighlightText textColor=\"red\">ReferenceError: Cannot access 'userName' before initialization</HighlightText >\n</Callout>\n<br/>\n‘userName’이 초기화되기 전에 접근할 수 없다는 참조 에러가 뜨게 됩니다. \n해당 코드 라인이 실행되는 시점에서 선언하지 않는 변수에 접근할 수 없는 게 우리가 예측할 수 있는 동작이므로 안심이 됩니다.\n그런데 한 가지 의문인 점은 왜 ReferenceError: userName is not defined가 아닌 걸까요?\n그 이유는 const와 let 또한 호이스팅 현상이 발생하기 때문입니다. 다만 var와의 차이점은 **const와 let은 호이스팅과 동시에 변수가 초기화 되지 않는다는 것**입니다. \n<HighlightText type=\"background\" fontWeight={700}>TDZ(Temporal Dead Zone)</HighlightText>, 일시적 사각지대라고 하여 **변수 선언이 인식된 후 변수가 초기화 되기 전까지의 구간에서 const와 let 키워드로 선언한 변수에 접근하면 참조 에러가 발생**하게 됩니다.\n\nconst와 let으로 선언한 변수는 자바스크립트 엔진이 변수 선언문에 도달했을 때 초기화되고 접근이 가능해집니다. 이때 **const는 재할당이 불가능하기 때문에 초기화와 동시에 값이 할당**되어야 합니다. let은 할당 값이 없다면 undefined로 초기화됩니다.\n<br/>\n#### const의 호이스팅\n<br/>\n![const의 호이스팅](https://drive.google.com/uc?export=view&id=1e6ONONIaXB_0jj3nXJUnFdZbrImqp5EH)\n<br/>\n> 1. 변수 선언이 끌어올려진 후 초기화 되지 않아 접근할 수 없음 <br/>(ReferenceError: Cannot access 'password' before initialization)\n> 2. 값을 재할당 할 수 없는 상수(constant)이기에 초기화와 동시에 할당\n> 3. 할당된 값 123456 출력\n\n<br/>\n#### let의 호이스팅\n<br/>\n![let의 호이스팅](https://drive.google.com/uc?export=view&id=1IwziOv60kqGAzwjJjoAO8oqOFbVeNE-v)\n<br/>\n> 1. 변수 선언이 끌어올려진 후 초기화 되지 않아 접근할 수 없음 <br/>(ReferenceError: Cannot access 'password' before initialization)\n> 2. 선언 후 값을 할당하지 않으면 undefined로 초기화 \n> 3. 초기화 된 undefined 출력\n> 4. 값 123456 할당\n> 5. 할당된 123456 출력\n\n<br/>\n## var를 지양해야 하는 이유\n<br/>\n - 재선언이 가능해 기존 선언을 덮어 쓸 수 있는 위험이 있습니다.\n - 호이스팅으로 인하여 변수 선언문 이전에 변수에 접근 가능한 예기치 못한 동작이 발생합니다.\n - 함수 스코프이기 때문에 if문, for문 등 문에서 쓰인 변수가 전역 변수가 되어 코드 여기 저기서 접근이 가능하고 변수 간 충돌이 발생할 수 위험이 있습니다.\n<br/>\n=> 따라서 코드의 예측 가능성과 안정성을 저하시키는 var를 지양하고 이를 보완하기 위해 나온 const와 let을 사용하는 것을 적극 권장합니다👍\n<br/>\n## 포스팅을 마치며\n<br/>\n이렇게 var의 특징과 그 특징으로부터 발생하는 위험성에 대해 알아보았습니다. var를 사용하면 코드가 일단 돌아는가지만 왜 돌아가는지 혼란스럽고, 왜 여기서 내가 예상한 동작과 다른 버그가 발생하는지 파악하는 데 시간을 허비하게 될 가능성이 크겠죠. 그렇기 때문에 요즘에는 var를 사용하지 않는 추세입니다. 다만 사용하지 않으니 알아두지 않는 것이 아니라 어떤 특징을 가지고 있었는지, 그 특징으로부터 어떤 불편함이 발생했는지, 불편을 해소하기 위해 어떻게 해야 하는지 알아두는 것이 중요하다고 생각합니다. 그리고 ES6가 나온 이후에 개발을 시작한 것이 얼마나 큰 행복인지도요🥹\n\n\n\n\n\n\n\n\n","title":"var는 왜 더이상 사용되지 않을까","subTitle":"var와 const, let의 차이점 알아보기","intro":"혹시 자바스크립트에서 var 사용을 지양하라는 말을 들어보셨나요? \n var는 한때 자바스크립트에서 변수를 선언할 수 있는 유일한 키워드였습니다. 하지만 ES6부터 모던 자바스크립트를 사용하는 개발자들은 더 이상 var를 사용하지 않고 있습니다. ES6부터 포함된 const와 let이라는 변수 선언 키워드가 있기 때문입니다. 하지만 var를 사용하지 않는 이유가 그저 오래된 문법이라서일까요? var와 const, let의 차이점을 알아보며 var가 외면받는 이유에 대해 알아보겠습니다.","isFeatured":true,"createdAt":"2024-07-24","thumbnail":"https://drive.google.com/uc?export=view&id=1KhO3x8PP7eh40G3ux4RsEg40L32eVkuC","keywords":"자바스크립트, javascript, 변수, variables, var, const, let, hoisting, 호이스팅, scope"}],"categoryName":"Javascript"},"__N_SSG":true}