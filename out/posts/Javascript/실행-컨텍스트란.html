<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><title>실행 컨텍스트란? | Yun&#x27;s Dev Log</title><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><meta http-equiv="X-UA-Compatible" content="IE=edge"/><meta name="keywords" content="자바스크립트, javascript, 실행 컨텍스트, execution context, call stack, hoisting, scope"/><meta name="description" content="2024-08-12"/><meta property="og:title" content="실행 컨텍스트란?"/><meta property="og:description" content="2024-08-12"/><meta property="og:image" content="https://drive.google.com/uc?export=view&amp;id=159jGroEmKvVBVvLL9C77eprzuvnbccBn"/><meta name="next-head-count" content="10"/><link rel="icon" href="/favicon/favicon.ico" sizes="any"/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/dev-log/_next/static/chunks/polyfills-78c92fac7aa8fdd8.js"></script><script src="/scripts/controlColorTheme.js" defer="" data-nscript="beforeInteractive"></script><script defer="" src="/dev-log/_next/static/chunks/237.f617120547efd146.js"></script><script defer="" src="/dev-log/_next/static/chunks/925.d1147afb5fb2fa7d.js"></script><script defer="" src="/dev-log/_next/static/chunks/675-13fd5e310eff19b0.js"></script><script defer="" src="/dev-log/_next/static/chunks/814.97619cc949df0a7c.js"></script><script defer="" src="/dev-log/_next/static/chunks/181.caa4158faff447ce.js"></script><script defer="" src="/dev-log/_next/static/chunks/703.f3e679770b665ca2.js"></script><script src="/dev-log/_next/static/chunks/webpack-dcbb21c87370b2d0.js" defer=""></script><script src="/dev-log/_next/static/chunks/framework-5866cead997b9ace.js" defer=""></script><script src="/dev-log/_next/static/chunks/main-34080fb2c09c2911.js" defer=""></script><script src="/dev-log/_next/static/chunks/pages/_app-aba757bda1cadccf.js" defer=""></script><script src="/dev-log/_next/static/chunks/664-2bebff42daeb5deb.js" defer=""></script><script src="/dev-log/_next/static/chunks/473-f1052ffcd80437d7.js" defer=""></script><script src="/dev-log/_next/static/chunks/pages/posts/%5Bcategory%5D/%5Bslug%5D-b66fd9054f440daf.js" defer=""></script><script src="/dev-log/_next/static/D2kP1jcyZ981G6yj10vNT/_buildManifest.js" defer=""></script><script src="/dev-log/_next/static/D2kP1jcyZ981G6yj10vNT/_ssgManifest.js" defer=""></script></head><body><div id="__next"><style data-emotion="css-global dvgpy8">:root{--color-primary:#262626;--color-secondary:#404040;--color-tertiary:#525252;--color-background-element:#e5e5e5;--color-background-global:#fff;--color-border:#e5e5e5;}:root .dark{--color-primary:#f5f5f5;--color-secondary:#e5e5e5;--color-tertiary:#d4d4d4;--color-background-element:#404040;--color-background-global:#262626;--color-border:#737373;}html,body,div,span,applet,object,iframe,h1,h2,h3,h4,h5,h6,p,blockquote,pre,a,abbr,acronym,address,big,cite,code,del,dfn,em,img,ins,kbd,q,s,samp,small,strike,strong,sub,sup,tt,var,b,u,i,center,dl,dt,dd,ol,ul,li,fieldset,form,label,legend,table,caption,tbody,tfoot,thead,tr,th,td,article,aside,canvas,details,embed,figure,figcaption,footer,header,hgroup,menu,nav,output,ruby,section,summary,time,mark,audio,video,button{margin:0;padding:0;border:0;vertical-align:baseline;box-sizing:border-box;}article,aside,details,figcaption,figure,footer,header,hgroup,menu,nav,section{display:block;}body{line-height:1;}blockquote,q{quotes:none;}blockquote:before,blockquote:after,q:before,q:after{content:"";content:none;}table{border-collapse:collapse;border-spacing:0;}ol,ul{list-style:none;}a,button{cursor:pointer;}button{border:none;outline:none;background-color:transparent;font-size:inherit;font-weight:inherit;line-height:inherit;color:inherit;}a{-webkit-text-decoration:none;text-decoration:none;color:inherit;}@import url("https://cdn.jsdelivr.net/gh/orioncactus/pretendard@v1.3.9/dist/web/variable/pretendardvariable.min.css");html{font-size:16px;}@media (min-width: 1080px){html{font-size:18px;}}body{background-color:var(--color-background-global);color:var(--color-secondary);font-family:"Pretendard Variable",Pretendard,-apple-system,BlinkMacSystemFont,system-ui,Roboto,"Helvetica Neue","Segoe UI","Apple SD Gothic Neo","Noto Sans KR","Malgun Gothic","Apple Color Emoji","Segoe UI Emoji","Segoe UI Symbol",sans-serif;font-weight:400;line-height:1.6;letter-spacing:0.00938em;}.visually-hidden{position:absolute!important;width:1px!important;height:1px!important;padding:0!important;margin:-1px!important;overflow:hidden!important;clip:rect(0, 0, 0, 0)!important;white-space:nowrap!important;border:0!important;}</style><div class="css-0"><style data-emotion="css zuuo44">.css-zuuo44{width:100%;}@media (min-width: 1080px){.css-zuuo44{margin-left:auto;width:80%;max-width:calc(100% - 220px);}}</style><div class="css-zuuo44"><style data-emotion="css qo0yyd">.css-qo0yyd{position:-webkit-sticky;position:sticky;top:0;right:0;z-index:50;padding:0 20px;width:100%;height:52px;background-color:rgba(255, 255, 255, 0.2);border-bottom:1px solid var(--color-border);-webkit-backdrop-filter:blur(10px);backdrop-filter:blur(10px);-webkit-transition:-webkit-transform 200ms ease-in-out;transition:transform 200ms ease-in-out;}.css-qo0yyd.is-hide{-webkit-transform:translateY(-100%);-moz-transform:translateY(-100%);-ms-transform:translateY(-100%);transform:translateY(-100%);}@media (min-width: 1080px){.css-qo0yyd{height:56px;}}</style><header class=" css-qo0yyd"><style data-emotion="css 1uwonur">.css-1uwonur{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-box-pack:justify;-webkit-justify-content:space-between;justify-content:space-between;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;}</style><nav class="css-1uwonur"><h2 class="visually-hidden">블로그 대메뉴</h2><style data-emotion="css guxf6x">.css-guxf6x{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;}</style><ul class="css-guxf6x"><style data-emotion="css 3rt8qm">.css-3rt8qm a{display:inline-block;position:relative;padding:12px;}.css-3rt8qm a::after{content:"";position:absolute;bottom:0;left:0;width:100%;height:2px;background-color:transparent;}.css-3rt8qm.is-active a::after{background-color:var(--color-secondary);}</style><li class=" css-3rt8qm"><a href="/dev-log"><style data-emotion="css 1gs3x7d">.css-1gs3x7d{line-height:1.6;letter-spacing:0.00938em;font-size:18px;font-size:700;color:var(--color-primary);}.css-1gs3x7d[class^="typography-h"],.css-1gs3x7d[class^="typography-subtitle"]{font-weight:600;}.css-1gs3x7d[class^="typography-body"]{font-weight:400;}@media (min-width: 1080px){.css-1gs3x7d{font-size:20px;}}</style><span class="typography-subtitle1  css-1gs3x7d">홈</span></a></li><li class=" css-3rt8qm"><a href="/dev-log/posts"><span class="typography-subtitle1  css-1gs3x7d">게시글 목록</span></a></li></ul></nav></header><style data-emotion="css 94ewza">.css-94ewza{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;gap:12px;position:fixed;top:0;right:16px;z-index:100;height:52px;}@media (min-width: 1080px){.css-94ewza{right:32;height:56px;}}</style><div class="css-94ewza"><style data-emotion="css dj5yub">.css-dj5yub{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-box-pack:center;-ms-flex-pack:center;-webkit-justify-content:center;justify-content:center;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;}.css-dj5yub svg{width:24px;height:24px;}</style><button aria-label="다크모드로 변경하기" class="css-dj5yub"><svg width="24" height="24" viewBox="0 0 24 24" fill="var(--color-primary)" xmlns="http://www.w3.org/2000/svg"><path d="M19.9 2.307a.483.483 0 0 0-.9 0l-.43 1.095a.484.484 0 0 1-.272.274l-1.091.432a.486.486 0 0 0 0 .903l1.091.432c.125.049.223.148.272.273L19 6.81c.162.41.74.41.9 0l.43-1.095a.484.484 0 0 1 .273-.273l1.091-.432a.486.486 0 0 0 0-.903l-1.091-.432a.484.484 0 0 1-.273-.274l-.43-1.095ZM16.033 8.13a.483.483 0 0 0-.9 0l-.157.399a.484.484 0 0 1-.272.273l-.398.158a.486.486 0 0 0 0 .903l.398.157c.125.05.223.148.272.274l.157.399c.161.41.739.41.9 0l.157-.4a.484.484 0 0 1 .272-.273l.398-.157a.486.486 0 0 0 0-.903l-.398-.158a.484.484 0 0 1-.272-.273l-.157-.4Z" fill="current"></path><path d="M12 22c5.523 0 10-4.477 10-10 0-.463-.694-.54-.933-.143a6.5 6.5 0 1 1-8.924-8.924C12.54 2.693 12.463 2 12 2 6.477 2 2 6.477 2 12s4.477 10 10 10Z" fill="current"></path></svg><span class="visually-hidden">다크모드로 변경하기</span></button><a href="mailto:ysisys0202@gmail.com"><div aria-label="이메일 보기" class="css-dj5yub"><svg width="24" height="24" viewBox="0 0 48 48" xmlns="http://www.w3.org/2000/svg" fill="var(--color-primary)"><path d="M0 0h48v48H0z" fill="none"></path><path d="M24 44c5.343 0 10.365-2.08 14.143-5.858l-2.829-2.828A15.895 15.895 0 0 1 24 40c-8.822 0-16-7.178-16-16S15.178 8 24 8s16 7.178 16 16c0 2.206-1.794 4-4 4s-4-1.794-4-4v-8h-4v1.079A7.955 7.955 0 0 0 24 16a8 8 0 0 0 0 16 7.976 7.976 0 0 0 6.003-2.723A7.975 7.975 0 0 0 36 32c4.411 0 8-3.589 8-8 0-11.028-8.972-20-20-20S4 12.972 4 24s8.972 20 20 20zm0-16c-2.206 0-4-1.794-4-4s1.794-4 4-4 4 1.794 4 4-1.794 4-4 4z"></path></svg><span class="visually-hidden">이메일 보기</span></div></a></div><main><style data-emotion="css tgaap8">.css-tgaap8{padding:32px 24px 80px;}@media (min-width: 1080px){.css-tgaap8{padding:48px 24px 80px;width:80%;max-width:calc(100% - 230px);}}@media (min-width: 1320px){.css-tgaap8{padding:48px 56px 80px;max-width:860px;}}</style><div id="post-container" class="css-tgaap8"><style data-emotion="css 12u75z1">.css-12u75z1{margin-top:24px;}@media (min-width: 1080px){.css-12u75z1{margin-top:32px;}}</style><article class="css-12u75z1"><style data-emotion="css 1bh2vrl">.css-1bh2vrl{padding-bottom:48px;}</style><header class="css-1bh2vrl"><div><a href="/dev-log/posts/Javascript"><style data-emotion="css 11miuq7">.css-11miuq7{display:-webkit-inline-box;display:-webkit-inline-flex;display:-ms-inline-flexbox;display:inline-flex;-webkit-box-pack:center;-ms-flex-pack:center;-webkit-justify-content:center;justify-content:center;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;border-radius:20px;padding:4px 12px;font-size:12px;line-height:1.4;border:1px solid;background-color:transparent;color:var(--color-primary);border-color:var(--color-primary);}</style><div class="css-11miuq7">Javascript</div></a><style data-emotion="css 1d8q2lt">.css-1d8q2lt{margin-top:8px;}</style><style data-emotion="css 168di4w">.css-168di4w{line-height:1.6;letter-spacing:0.00938em;font-size:32px;color:var(--color-primary);margin-top:8px;}.css-168di4w[class^="typography-h"],.css-168di4w[class^="typography-subtitle"]{font-weight:600;}.css-168di4w[class^="typography-body"]{font-weight:400;}@media (min-width: 1080px){.css-168di4w{font-size:36px;}}</style><h1 class="typography-h1 css-168di4w">실행 컨텍스트란?</h1><style data-emotion="css ems5xl">.css-ems5xl{margin-top:4px;}</style><style data-emotion="css 16kssqz">.css-16kssqz{margin-top:4px;}</style><div class="css-16kssqz"><style data-emotion="css hij6lw">.css-hij6lw::after{content:":";margin:0 4px;}</style><style data-emotion="css 1k2vjrr">.css-1k2vjrr{line-height:1.6;letter-spacing:0.00938em;font-size:14px;color:var( --color-tertiary);}.css-1k2vjrr[class^="typography-h"],.css-1k2vjrr[class^="typography-subtitle"]{font-weight:600;}.css-1k2vjrr[class^="typography-body"]{font-weight:400;}@media (min-width: 1080px){.css-1k2vjrr{font-size:15px;}}.css-1k2vjrr::after{content:":";margin:0 4px;}</style><span class="typography-body2 css-1k2vjrr">최종 수정일</span><style data-emotion="css 1dhx26">.css-1dhx26{line-height:1.6;letter-spacing:0.00938em;font-size:14px;color:var( --color-tertiary);}.css-1dhx26[class^="typography-h"],.css-1dhx26[class^="typography-subtitle"]{font-weight:600;}.css-1dhx26[class^="typography-body"]{font-weight:400;}@media (min-width: 1080px){.css-1dhx26{font-size:15px;}}</style><span class="typography-body2 value css-1dhx26">2024년 8월 12일</span></div></div></header><style data-emotion="css d3ymdl">.css-d3ymdl{word-break:keep-all;}.css-d3ymdl p{white-space:pre-wrap;}.css-d3ymdl del{font-size:14px;color:var( --color-tertiary);}.css-d3ymdl table{background-color:var(--color-background-global);}.css-d3ymdl table thead{border-bottom:2px solid var(--color-border);}.css-d3ymdl table th,.css-d3ymdl table td{padding:10px 16px;border:1px solid var(--color-border);}.css-d3ymdl a{-webkit-text-decoration:underline;text-decoration:underline;}.css-d3ymdl a::after{content:"↗️";font-size:0.6em;}.css-d3ymdl ol{list-style:decimal;}.css-d3ymdl ul{list-style:disc;}.css-d3ymdl li{margin-left:16px;}.css-d3ymdl li:not(:first-of-type){margin-top:8px;}.css-d3ymdl blockquote{position:relative;padding:12px 24px;background-color:var(--color-background-element);font-size:15px;}@media (min-width: 1080px){.css-d3ymdl blockquote{font-size:16px;}}.css-d3ymdl blockquote::before{content:"";position:absolute;top:0;left:0;width:4px;height:100%;background-color:var(--color-primary);}</style><div class="css-d3ymdl"><p>이전에 변수 이야기를 하며 호이스팅, 스코프 체인 이야기를 언급했는데요. 왜 그런 현상이 일어나는지 궁금하지 않으셨나요? 실행 컨텍스트를 알게 되면 많은 궁금증이 풀리게 됩니다. 얼른 실행 컨텍스트에 대해 알아보러 갑시다.</p>
<style data-emotion="css 1cwv52n">.css-1cwv52n{height:24px;background-color:transparent;}</style><div aria-hidden="false" class="css-1cwv52n"></div>
<style data-emotion="css f925jc">.css-f925jc{line-height:1.6;letter-spacing:0.00938em;font-size:22px;color:var(--color-primary);}.css-f925jc[class^="typography-h"],.css-f925jc[class^="typography-subtitle"]{font-weight:600;}.css-f925jc[class^="typography-body"]{font-weight:400;}@media (min-width: 1080px){.css-f925jc{font-size:28px;}}</style><h2 class="typography-h3  css-f925jc" id="실행-컨텍스트란">실행 컨텍스트란?</h2>
<br/>
<p>실행 컨텍스트란 코드를 실행할 때 필요한 문맥을 의미합니다. 글을 읽을 때 문맥을 파악하라는 말을 자주 하죠? 어휘의 의미와 문장의 앞 뒤 상황을 이해하여 글의 흐름을 파악하라는 말인데요. 실행 컨텍스트도 이와 비슷합니다. <strong>실행 컨텍스트는 코드의 실행과 관련된 환경 정보</strong>입니다. 이를 통해 현재 실행되는 코드 내의 식별자 정보와 외부 환경 참조, 함수 실행 순서 등을 관리하게 되는 것이죠.</p>
<br/>
<h2 class="typography-h3  css-f925jc" id="실행-컨텍스트의-생성제거-시점">실행 컨텍스트의 생성/제거 시점</h2>
<br/>
<p>실행 컨텍스트는 코드가 실행되기 전 생성되며, 코드 실행이 완료되면 제거됩니다.
자바스크립트 소스 코드 타입에 따른 실행 컨텍스트가 생성/제거 시점은 다음과 같습니다</p>
<br/>
<style data-emotion="css 1f3zz6o">.css-1f3zz6o{line-height:1.6;letter-spacing:0.00938em;font-size:20px;color:var(--color-primary);}.css-1f3zz6o[class^="typography-h"],.css-1f3zz6o[class^="typography-subtitle"]{font-weight:600;}.css-1f3zz6o[class^="typography-body"]{font-weight:400;}@media (min-width: 1080px){.css-1f3zz6o{font-size:24px;}}</style><h3 class="typography-h4  css-1f3zz6o" id="--전역-코드">- 전역 코드</h3>
<p>함수, 코드 블럭 외부의 코드로 코드가 처음 실행될 때 컨텍스트가 생성되고 페이지가 종료될 때까지 유지됩니다.</p>
<br/>
<h3 class="typography-h4  css-1f3zz6o" id="--함수-코드">- 함수 코드</h3>
<p>함수 내부에 존재하는 코드로 함수가 호출 될 때 컨텍스트가 생성되고 함수가 종료되는 시점에서 컨텍스트가 제거됩니다. if문, for문과 같은 문(statement)에서는 실행 컨텍스트가 생성되지 않습니다.</p>
<br/>
<h3 class="typography-h4  css-1f3zz6o" id="--eval-코드">- eval 코드</h3>
<p>문자열로 표현된 코드를 실행할 수 있게 해주는 <strong>eval</strong> 함수에 인수로 전달되어 실행되는 코드입니다. eval 함수가 호출될 때 컨텍스트가 생성되고, <strong>eval</strong> 함수가 실행한 코드가 종료되는 시점에 컨텍스트가 종료됩니다.</p>
<br/>
<style data-emotion="css 1f46fsl">.css-1f46fsl{position:relative;padding:11px 8px 12px 28px;background-color:var(--color-background-element);}</style><article class="css-1f46fsl"><style data-emotion="css 1c2gy26">.css-1c2gy26{position:absolute;top:12px;left:8px;}</style><style data-emotion="css oig4aq">.css-oig4aq{line-height:1.6;letter-spacing:0.00938em;font-size:16px;position:absolute;top:12px;left:8px;}.css-oig4aq[class^="typography-h"],.css-oig4aq[class^="typography-subtitle"]{font-weight:600;}.css-oig4aq[class^="typography-body"]{font-weight:400;}@media (min-width: 1080px){.css-oig4aq{font-size:18px;}}</style><span class="typography-body1 css-oig4aq">🚨</span><p class="typography-body2  css-1dhx26">eval은 문자열로 입력받은 코드가 악의적인 내용을 포함하는 등 보안상 위험이 생길 수 있기에 사용을 지양하고 있습니다.</p></article>
<br/>
<h3 class="typography-h4  css-1f3zz6o" id="--module-코드">- module 코드</h3>
<p>자바스크립트 module 내부에 존재하는 코드로 module이 import 되는 순간 컨텍스트가 생성되며 해당 모듈 코드가 종료될 때 컨텍스트가 제거됩니다.</p>
<br/>
<h2 class="typography-h3  css-f925jc" id="콜-스택을-통한-함수-실행-순서-관리">콜 스택을 통한 함수 실행 순서 관리</h2>
<br/>
<p>일단 콜 스택에 대해 알아보기 전에, 스택에 대해 알고 계시나요? 스택이란 후입선출(LIFO, Last In First Out) 방식의 자료구조를 의미합니다. 즉, <strong>마지막에 들어온 데이터가 가장 먼저 나가게 되는 것</strong>이죠.</p>
<br/>
<div><style data-emotion="css 11z8347">.css-11z8347{max-width:100%;height:auto;}</style><img alt="스택" loading="lazy" width="375" height="439" decoding="async" data-nimg="1" class="css-11z8347" style="color:transparent" srcSet="?url=https%3A%2F%2Fdrive.google.com%2Fuc%3Fexport%3Dview%26id%3D14L-2EurAc37t_OeTgtjXLR3eDdOuTTSe&amp;w=384&amp;q=75 1x, ?url=https%3A%2F%2Fdrive.google.com%2Fuc%3Fexport%3Dview%26id%3D14L-2EurAc37t_OeTgtjXLR3eDdOuTTSe&amp;w=750&amp;q=75 2x" src="?url=https%3A%2F%2Fdrive.google.com%2Fuc%3Fexport%3Dview%26id%3D14L-2EurAc37t_OeTgtjXLR3eDdOuTTSe&amp;w=750&amp;q=75"/></div>
<br/>
<p>콜 스택은 자바스크립트에서 함수 호출 시 생성되는 실행 컨텍스트를 관리하는 스택 자료구조인데요. 함수가 호출될 때 마다 콜 스택에 호출된 함수의 실행 컨텍스트가 차곡차곡 쌓이게 됩니다. 이때 가장 위에 쌓인 실행 컨텍스트를 가진 함수가 가장 먼저 실행됩니다. 즉 가장 니중에 호출된 함수가 가장 먼저 실행되는 것이죠.</p>
<br/>
<p>함수 실행이 완료되면, 그 함수의 실행 컨텍스트는 콜 스택에서 제거되고 그 다음으로 쌓인 실행 컨텍스트의 함수가 실행됩니다. 이렇게 콜 스택을 통해 함수의 실행 순서를 보장하게 되는 것이죠.</p>
<br/>
<pre><section><style data-emotion="css 19ewdi0">.css-19ewdi0{padding:8px;border-radius:4px 4px 0 0;background-color:#a3a3a3;}</style><header class="css-19ewdi0"><style data-emotion="css 1fte3e1">.css-1fte3e1{line-height:1.6;letter-spacing:0.00938em;font-size:16px;}.css-1fte3e1[class^="typography-h"],.css-1fte3e1[class^="typography-subtitle"]{font-weight:600;}.css-1fte3e1[class^="typography-body"]{font-weight:400;}@media (min-width: 1080px){.css-1fte3e1{font-size:18px;}}</style><span class="typography-body1  css-1fte3e1">javascript</span></header><style data-emotion="css 4iulct">.css-4iulct{margin:0!important;}</style><pre class="css-4iulct" style="text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;color:#eee;background:#2f2f2f;font-family:Roboto Mono, monospace;font-size:1em;line-height:1.5em;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;overflow:auto;position:relative;margin:0.5em 0;padding:1.25em 1em"><code class="language-javascript" style="text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;color:#eee;background:#2f2f2f;font-family:Roboto Mono, monospace;font-size:1em;line-height:1.5em;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none"><span>
</span><span></span><span class="token token console" style="color:#f2ff00">console</span><span class="token token" style="color:#89ddff">.</span><span class="token token method property-access" style="color:#c792ea">log</span><span class="token token" style="color:#89ddff">(</span><span class="token token" style="color:#a5e844">&quot;1. 전역 컨텍스트&quot;</span><span class="token token" style="color:#89ddff">)</span><span class="token token" style="color:#89ddff">;</span><span>
</span>
<span></span><span class="token token" style="color:#c792ea">function</span><span> </span><span class="token token" style="color:#c792ea">outerFunc</span><span> </span><span class="token token" style="color:#89ddff">(</span><span class="token token" style="color:#89ddff">)</span><span> </span><span class="token token" style="color:#89ddff">{</span><span>
</span><span>	</span><span class="token token console" style="color:#f2ff00">console</span><span class="token token" style="color:#89ddff">.</span><span class="token token method property-access" style="color:#c792ea">log</span><span class="token token" style="color:#89ddff">(</span><span class="token token" style="color:#a5e844">&quot;1. outerFunc 컨텍스트&quot;</span><span class="token token" style="color:#89ddff">)</span><span class="token token" style="color:#89ddff">;</span><span>
</span>	
<span>	</span><span class="token token" style="color:#c792ea">function</span><span> </span><span class="token token" style="color:#c792ea">innerFunc</span><span> </span><span class="token token" style="color:#89ddff">(</span><span class="token token" style="color:#89ddff">)</span><span> </span><span class="token token" style="color:#89ddff">{</span><span>
</span><span>		</span><span class="token token console" style="color:#f2ff00">console</span><span class="token token" style="color:#89ddff">.</span><span class="token token method property-access" style="color:#c792ea">log</span><span class="token token" style="color:#89ddff">(</span><span class="token token" style="color:#a5e844">&quot;2. innerFunc 컨텍스트&quot;</span><span class="token token" style="color:#89ddff">)</span><span class="token token" style="color:#89ddff">;</span><span>
</span><span>	</span><span class="token token" style="color:#89ddff">}</span><span>
</span>	
<span>	</span><span class="token token" style="color:#c792ea">innerFunc</span><span class="token token" style="color:#89ddff">(</span><span class="token token" style="color:#89ddff">)</span><span class="token token" style="color:#89ddff">;</span><span>
</span><span></span><span class="token token" style="color:#89ddff">}</span><span>
</span>
<span></span><span class="token token" style="color:#c792ea">outerFunc</span><span class="token token" style="color:#89ddff">(</span><span class="token token" style="color:#89ddff">)</span><span class="token token" style="color:#89ddff">;</span><span>
</span>
<span></span><span class="token token console" style="color:#f2ff00">console</span><span class="token token" style="color:#89ddff">.</span><span class="token token method property-access" style="color:#c792ea">log</span><span class="token token" style="color:#89ddff">(</span><span class="token token" style="color:#a5e844">&quot;4. 함수 실행 컨텍스트가 모두 제거 된 후 전역 컨텍스트만 call stack에 남음&quot;</span><span class="token token" style="color:#89ddff">)</span><span class="token token" style="color:#89ddff">;</span><span>
</span></code></pre></section></pre>
<br/>
<p>위와 같은 코드가 있을 때 콜 스택에 컨텍스트가 쌓이는 과정을 보겠습니다.</p>
<br/>
<div><img alt="실행 컨텍스트가 call stack에 쌓이는 과정" loading="lazy" width="688" height="523" decoding="async" data-nimg="1" class="css-11z8347" style="color:transparent" srcSet="?url=https%3A%2F%2Fdrive.google.com%2Fuc%3Fexport%3Dview%26id%3D1Fce2nPOfLqWtHkuYP-4kPc6vDcyZosRs&amp;w=750&amp;q=75 1x, ?url=https%3A%2F%2Fdrive.google.com%2Fuc%3Fexport%3Dview%26id%3D1Fce2nPOfLqWtHkuYP-4kPc6vDcyZosRs&amp;w=1920&amp;q=75 2x" src="?url=https%3A%2F%2Fdrive.google.com%2Fuc%3Fexport%3Dview%26id%3D1Fce2nPOfLqWtHkuYP-4kPc6vDcyZosRs&amp;w=1920&amp;q=75"/></div>
<br/>
<blockquote>
<ol>
<li>전역 컨텍스트 생성 -&gt; 콜 스택에 쌓임 -&gt; &#x27;console.log(&quot;1. 전역 컨텍스트&quot;)&#x27; 실행</li>
<li>outerFunc 호출 -&gt; outerFunc 실행 컨텍스트 생성 -&gt; 콜 스택에 쌓임 -&gt; &#x27;console.log(&quot;2. outerFunc 컨텍스트&quot;);&#x27; 실행</li>
<li>innerFunc 호출 -&gt; innerFunc 실행 컨텍스트 생성 -&gt; 콜 스택에 쌓임 -&gt; &#x27;console.log(&quot;3. innerFunc 컨텍스트&quot;)&#x27; 실행</li>
<li>innerFunc 함수 종료 -&gt; 콜 스택에서 제거.</li>
<li>outerFunc로 복귀 -&gt; outerFunc 함수 종료 -&gt; 콜 스택에서 제거.</li>
<li>전역 컨텍스트로 복귀 -&gt; console.log(&quot;4. 함수 실행 컨텍스트가 모두 제거 된 후 전역 컨텍스트만 call stack에 남음&quot;); 실행, 전역 컨테스트는 페이지가 종료될 때 까지 유지.</li>
</ol>
</blockquote>
<br/>
<p>이와 같이 코드가 실행되다가 함수가 호출되면 해당 함수의 실행 컨텍스트가 콜스택에 쌓이게 되고 해당 함수가 실행됩니다. 함수가 종료되고 콜스택에서 제거되면 이전 컨텍스트의 함수가 이어서 실행되게 됩니다.</p>
<br/>
<h2 class="typography-h3  css-f925jc" id="실행-컨텍스트에-담긴-정보">실행 컨텍스트에 담긴 정보</h2>
<br/>
<p>그럼 이제 실행 컨텍스트에 어떤 정보가 담겨있을지 알아보도록 하겠습니다.</p>
<br/>
<h3 class="typography-h4  css-1f3zz6o" id="--variableenvironment-변수-환경">- VariableEnvironment (변수 환경)</h3>
<br/>
<p>VariableEnvironment는 컨텍스트 생성 시의 식별자 정보와 외부 환경 참조 정보를 가지고 있습니다. 컨텍스트 생성 될 때 컨텍스트의 내의 식별자를 수집합니다. var의 경우 수집과 동시에 undefined로 초기화됩니다. 컨텍스트 생성 당시의 상태를 기억하며 코드 진행 중에 값이 변경되지 않습니다. LexicalEnvironment와 동일한 구조를 가지기 때문에 자세한 구조에 대해선 LexicalEnvironment에서 이야기 해보겠습니다.</p>
<br/>
<h3 class="typography-h4  css-1f3zz6o" id="--lexicalenvironment-어휘적-환경">- LexicalEnvironment (어휘적 환경)</h3>
<br/>
<p>LexicalEnvironment 역시 식별자 정보와 외부 환경 참조 정보를 가지고 있습니다. 컨텍스트가 생성 될 시점에는 VariableEnvironment를 복사하기 때문에 값이 동일하지만 코드가 실행됨에 따라 식별자 정보를 업데이트 합니다. (const, let으로 선언한 변수의 초기화, 변수 값 할당, 재할당 등)</p>
<br/>
<h4 class="typography-subtitle1  css-1gs3x7d" id="--environmentrecord-환경-기록">- environmentRecord (환경 기록)</h4>
<p>컨텍스트 내에서 수집된 식별자 정보가 있습니다.</p>
<br/>
<h4 class="typography-subtitle1  css-1gs3x7d" id="--outerenvironmentreference-외부-환경-참조">- outerEnvironmentReference (외부 환경 참조)</h4>
<p>현재 실행 컨텍스트의 외부 환경을 참조하는 정보입니다. 현재 컨텍스트에 식별자가 존재하지 않을 경우 외부 스코프에서 식별자를 검색합니다. 이를 통해 상위 스코프의 식별자에 접근할 수 있는 것을 스코프체인이라고 합니다. 내부 함수에서는 외부 함수의 식별자를 참조할 수 있지만 외부 함수에서 내부 함수에 참조할 수 없는 이유이기도 합니다.</p>
<br/>
<article class="css-1f46fsl"><span class="typography-body1 css-oig4aq">💡</span><style data-emotion="css 190br03">.css-190br03{margin-bottom:8px;font-weight:500!important;}</style><style data-emotion="css nunwm7">.css-nunwm7{line-height:1.6;letter-spacing:0.00938em;font-size:16px;color:var(--color-primary);margin-bottom:8px;font-weight:500!important;}.css-nunwm7[class^="typography-h"],.css-nunwm7[class^="typography-subtitle"]{font-weight:600;}.css-nunwm7[class^="typography-body"]{font-weight:400;}@media (min-width: 1080px){.css-nunwm7{font-size:18px;}}</style><h5 class="typography-body1 css-nunwm7">호이스팅</h5><p class="typography-body2  css-1dhx26">코드가 실행되기 전 식별자를 수집하는 과정에서 식별자가 코드의 상단으로 끌어올려진 것처럼 동작하는 호이스팅 현상이 발생하게 됩니다. 즉, 실제로 식별자가 코드 위로 끌어올려진 것이 아니라 <strong>environmentRecord</strong>에 수집된 식별자를 컨텍스트 내에서 접근할 수 있게 되는 것이죠. 이로인해 var를 사용한 변수 선언, 함수 선언문에 도달하지 않아도 해당 식별자에 접근할 수 있게 됩니다.</p></article>
<br/>
<article class="css-1f46fsl"><span class="typography-body1 css-oig4aq">💡</span><h5 class="typography-body1 css-nunwm7">var와 const, let의 차이</h5><p class="typography-body2  css-1dhx26">var는 변수 선언이 수집됨과 동시에 undefined로 초기화 되기 때문에 변수 선언문 전에 해당 변수에 접근이 가능했습니다. 이런 예기치 못한 동작을 보완하기 위해 나온 const, let은 선언문 이전에 변수가 초기화 되지 않는데요. 코드가 실행됨에 따라 변수 선언문에 도달했을 때 비로소 변수가 초기화되고 LexicalEnvironment가 업데이트 됩니다. 따라서 세 가지 키워드로 선언된 변수 모두 호이스팅 현상이 발생하지만 const, let은 변수 수집 후 초기화 되기 이전 영역인 TMZ(일시적 사각지대)에서는 변수에 접근할 수 없기 때문에 변수 선언문 이전에 접근할 수 없게 되는 것이죠.</p></article>
<br/>
<article class="css-1f46fsl"><span class="typography-body1 css-oig4aq">🤔</span><h5 class="typography-body1 css-nunwm7">블록은 어떻게 스코프를 생성할까?</h5><p class="typography-body2  css-1dhx26">실행 컨텍스트는 함수 호출 시에 생성된다고 이야기 했습니다. 그렇다면 블록에서는 어떻게 스코프가 만들어질까요? 바로 블록 코드가 실행될 때 LexicalEnvironment가 생성되기 떄문입니다. 이를 통해 블록 내부 식별자를 관리하고 스코프 체인을 통해 외부 환경의 식별자에도 접근할 수 있게 됩니다. 그리고 블록 내의 코드가 모두 종료 되었을 때 LexicalEnvironment가 제거됩니다.</p></article>
<br/>
<h3 class="typography-h4  css-1f3zz6o" id="--thisbindingthis-바인딩">- ThisBinding(This 바인딩)</h3>
<br/>
<p><strong>This Binding</strong>은 <strong>this</strong>의 값을 결정하는 정보로, 함수 호출 시 <strong>this</strong>가 참조할 객체를 결정합니다.</p>
<br/>
<h2 class="typography-h3  css-f925jc" id="포스팅을-마무리하며">포스팅을 마무리하며</h2>
<br/>
<p>이렇게 자바스크립트 코드가 실행될 때의 환경 정보인 실행 컨텍스트에 대해서 알아보았습니다. 이를 통해 호이스팅, 스코프 체이닝, this 바인딩 등 자바스크립트에서 발생하는 다양한 현상들에 대해 이해할 수 있었습니다. 이번 포스팅을 통해 원래 그런 것, 그냥 그런 것은 없다는 사실도 다시끔 느끼게 되었네요.</p>
<br/>
<p>사실 실행 컨텍스트는 블로그를 시작하며 언젠가 꼭 다뤄야지 했던 주제입니다. 처음 변수 포스팅을 할 때도 &#x27;아 이걸 설명하려면 실행 컨텍스트 이야기를 해야하는데&#x27; 하면서 어디부터 어디까지 이야기해야하나 참 고민이 많았는데 이렇게 포스팅할 수 있게 되어서 숙제를 덜어낸 기분입니다. 그럼 후련한 마음으로 글을 마무리 하도록 하겠습니다. 여기까지 긴 글 읽어주셔서 감사합니다.😊</p></div></article><style data-emotion="css r0nx3b">.css-r0nx3b{margin-top:48px;font-size:14px;color:var( --color-tertiary);text-align:center;}.css-r0nx3b a{-webkit-text-decoration:underline;text-decoration:underline;}@media (min-width: 1080px){.css-r0nx3b{margin-top:120px;}}</style><p class="css-r0nx3b">게시글의 오류 지적, 내용 보충, 질문 등의 피드백은 언제나 환영입니다.<br/>아래 댓글창 혹은<!-- --> <a href="mailto:ysisys0202@gmail.com">ysisys0202@gmail.com</a>으로 남겨주세요.</p><style data-emotion="css 1qrcejr">.css-1qrcejr{margin-top:80px;}</style><div id="post-comments-wrapper" class="css-1qrcejr"></div></div></main><style data-emotion="css kmicch">.css-kmicch{position:relative;z-index:1;margin-top:-1px;padding:40px 16px;border-top:1px solid var( --color-tertiary);background-color:var(--color-background-global);}</style><footer class="css-kmicch"><ul><style data-emotion="css 1sy8r3">.css-1sy8r3 a{-webkit-text-decoration:underline;text-decoration:underline;}</style><li class="css-1sy8r3"><p class="typography-body2  css-1dhx26">연락처 :<a href="mailto:ysisys0202@gmail.com"> ysisys0202@gmail.com</a></p></li><li class="css-1sy8r3"><p class="typography-body2  css-1dhx26">아이콘 출처 :<a href="https://www.flaticon.com/free-icons/manual-book" title="manual book icons"> Manual book icons created by Kreev Studio - Flaticon</a></p></li></ul></footer></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"postData":{"categoryId":"1","categoryName":"Javascript","slug":"실행-컨텍스트란","content":"\u003cp\u003e{intro}\u003c/p\u003e\n\u003cSpacing size=\"lg\" /\u003e\n## 실행 컨텍스트란?\n\u003cbr/\u003e\n실행 컨텍스트란 코드를 실행할 때 필요한 문맥을 의미합니다. 글을 읽을 때 문맥을 파악하라는 말을 자주 하죠? 어휘의 의미와 문장의 앞 뒤 상황을 이해하여 글의 흐름을 파악하라는 말인데요. 실행 컨텍스트도 이와 비슷합니다. **실행 컨텍스트는 코드의 실행과 관련된 환경 정보**입니다. 이를 통해 현재 실행되는 코드 내의 식별자 정보와 외부 환경 참조, 함수 실행 순서 등을 관리하게 되는 것이죠.\n\u003cbr/\u003e\n## 실행 컨텍스트의 생성/제거 시점\n\u003cbr/\u003e\n실행 컨텍스트는 코드가 실행되기 전 생성되며, 코드 실행이 완료되면 제거됩니다. \n자바스크립트 소스 코드 타입에 따른 실행 컨텍스트가 생성/제거 시점은 다음과 같습니다\n\u003cbr/\u003e\n### - 전역 코드\n함수, 코드 블럭 외부의 코드로 코드가 처음 실행될 때 컨텍스트가 생성되고 페이지가 종료될 때까지 유지됩니다.\n\u003cbr/\u003e\n### - 함수 코드\n함수 내부에 존재하는 코드로 함수가 호출 될 때 컨텍스트가 생성되고 함수가 종료되는 시점에서 컨텍스트가 제거됩니다. if문, for문과 같은 문(statement)에서는 실행 컨텍스트가 생성되지 않습니다.\n\u003cbr/\u003e\n### - eval 코드\n 문자열로 표현된 코드를 실행할 수 있게 해주는 **eval** 함수에 인수로 전달되어 실행되는 코드입니다. eval 함수가 호출될 때 컨텍스트가 생성되고, **eval** 함수가 실행한 코드가 종료되는 시점에 컨텍스트가 종료됩니다.\n\u003cbr/\u003e\n\u003cCallout icon=\"🚨\"\u003e\neval은 문자열로 입력받은 코드가 악의적인 내용을 포함하는 등 보안상 위험이 생길 수 있기에 사용을 지양하고 있습니다.\n\u003c/Callout\u003e\n\u003cbr/\u003e\n### - module 코드\n자바스크립트 module 내부에 존재하는 코드로 module이 import 되는 순간 컨텍스트가 생성되며 해당 모듈 코드가 종료될 때 컨텍스트가 제거됩니다.\n\u003cbr/\u003e\n## 콜 스택을 통한 함수 실행 순서 관리\n\u003cbr/\u003e\n일단 콜 스택에 대해 알아보기 전에, 스택에 대해 알고 계시나요? 스택이란 후입선출(LIFO, Last In First Out) 방식의 자료구조를 의미합니다. 즉, **마지막에 들어온 데이터가 가장 먼저 나가게 되는 것**이죠.\n\u003cbr/\u003e\n\u003cPostImage src=\"https://drive.google.com/uc?export=view\u0026id=14L-2EurAc37t_OeTgtjXLR3eDdOuTTSe\" alt=\"스택\" width=\"375\" height=\"439\"/\u003e\n\u003cbr/\u003e\n콜 스택은 자바스크립트에서 함수 호출 시 생성되는 실행 컨텍스트를 관리하는 스택 자료구조인데요. 함수가 호출될 때 마다 콜 스택에 호출된 함수의 실행 컨텍스트가 차곡차곡 쌓이게 됩니다. 이때 가장 위에 쌓인 실행 컨텍스트를 가진 함수가 가장 먼저 실행됩니다. 즉 가장 니중에 호출된 함수가 가장 먼저 실행되는 것이죠. \n\u003cbr/\u003e\n함수 실행이 완료되면, 그 함수의 실행 컨텍스트는 콜 스택에서 제거되고 그 다음으로 쌓인 실행 컨텍스트의 함수가 실행됩니다. 이렇게 콜 스택을 통해 함수의 실행 순서를 보장하게 되는 것이죠.\n\u003cbr/\u003e\n```javascript\n\nconsole.log(\"1. 전역 컨텍스트\");\n\nfunction outerFunc () {\n\tconsole.log(\"1. outerFunc 컨텍스트\");\n\t\n\tfunction innerFunc () {\n\t\tconsole.log(\"2. innerFunc 컨텍스트\");\n\t}\n\t\n\tinnerFunc();\n}\n\nouterFunc();\n\nconsole.log(\"4. 함수 실행 컨텍스트가 모두 제거 된 후 전역 컨텍스트만 call stack에 남음\");\n```\n\u003cbr/\u003e\n위와 같은 코드가 있을 때 콜 스택에 컨텍스트가 쌓이는 과정을 보겠습니다.\n\u003cbr/\u003e\n\u003cPostImage src=\"https://drive.google.com/uc?export=view\u0026id=1Fce2nPOfLqWtHkuYP-4kPc6vDcyZosRs\" alt=\"실행 컨텍스트가 call stack에 쌓이는 과정\" width=\"688\" height=\"523\"/\u003e\n\u003cbr/\u003e\n\u003e 1. 전역 컨텍스트 생성 -\u003e 콜 스택에 쌓임 -\u003e 'console.log(\"1. 전역 컨텍스트\")' 실행    \n\u003e 2. outerFunc 호출 -\u003e outerFunc 실행 컨텍스트 생성 -\u003e 콜 스택에 쌓임 -\u003e 'console.log(\"2. outerFunc 컨텍스트\");' 실행\n\u003e 3. innerFunc 호출 -\u003e innerFunc 실행 컨텍스트 생성 -\u003e 콜 스택에 쌓임 -\u003e 'console.log(\"3. innerFunc 컨텍스트\")' 실행\n\u003e 4. innerFunc 함수 종료 -\u003e 콜 스택에서 제거.\n\u003e 5. outerFunc로 복귀 -\u003e outerFunc 함수 종료 -\u003e 콜 스택에서 제거.\n\u003e 6. 전역 컨텍스트로 복귀 -\u003e console.log(\"4. 함수 실행 컨텍스트가 모두 제거 된 후 전역 컨텍스트만 call stack에 남음\"); 실행, 전역 컨테스트는 페이지가 종료될 때 까지 유지.\n\u003cbr/\u003e\n이와 같이 코드가 실행되다가 함수가 호출되면 해당 함수의 실행 컨텍스트가 콜스택에 쌓이게 되고 해당 함수가 실행됩니다. 함수가 종료되고 콜스택에서 제거되면 이전 컨텍스트의 함수가 이어서 실행되게 됩니다. \n\u003cbr/\u003e\n## 실행 컨텍스트에 담긴 정보\n\u003cbr/\u003e\n그럼 이제 실행 컨텍스트에 어떤 정보가 담겨있을지 알아보도록 하겠습니다.\n\u003cbr/\u003e\n### - VariableEnvironment (변수 환경)\n\u003cbr/\u003e\nVariableEnvironment는 컨텍스트 생성 시의 식별자 정보와 외부 환경 참조 정보를 가지고 있습니다. 컨텍스트 생성 될 때 컨텍스트의 내의 식별자를 수집합니다. var의 경우 수집과 동시에 undefined로 초기화됩니다. 컨텍스트 생성 당시의 상태를 기억하며 코드 진행 중에 값이 변경되지 않습니다. LexicalEnvironment와 동일한 구조를 가지기 때문에 자세한 구조에 대해선 LexicalEnvironment에서 이야기 해보겠습니다.  \n\u003cbr/\u003e\n### - LexicalEnvironment (어휘적 환경)\n\u003cbr/\u003e\nLexicalEnvironment 역시 식별자 정보와 외부 환경 참조 정보를 가지고 있습니다. 컨텍스트가 생성 될 시점에는 VariableEnvironment를 복사하기 때문에 값이 동일하지만 코드가 실행됨에 따라 식별자 정보를 업데이트 합니다. (const, let으로 선언한 변수의 초기화, 변수 값 할당, 재할당 등)\n\u003cbr/\u003e\n#### - environmentRecord (환경 기록)\n컨텍스트 내에서 수집된 식별자 정보가 있습니다.\n\u003cbr/\u003e\n#### - outerEnvironmentReference (외부 환경 참조)\n현재 실행 컨텍스트의 외부 환경을 참조하는 정보입니다. 현재 컨텍스트에 식별자가 존재하지 않을 경우 외부 스코프에서 식별자를 검색합니다. 이를 통해 상위 스코프의 식별자에 접근할 수 있는 것을 스코프체인이라고 합니다. 내부 함수에서는 외부 함수의 식별자를 참조할 수 있지만 외부 함수에서 내부 함수에 참조할 수 없는 이유이기도 합니다.\n\u003cbr/\u003e\n\u003cCallout title=\"호이스팅\"\u003e\n코드가 실행되기 전 식별자를 수집하는 과정에서 식별자가 코드의 상단으로 끌어올려진 것처럼 동작하는 호이스팅 현상이 발생하게 됩니다. 즉, 실제로 식별자가 코드 위로 끌어올려진 것이 아니라 **environmentRecord**에 수집된 식별자를 컨텍스트 내에서 접근할 수 있게 되는 것이죠. 이로인해 var를 사용한 변수 선언, 함수 선언문에 도달하지 않아도 해당 식별자에 접근할 수 있게 됩니다.\n\u003c/Callout\u003e\n\u003cbr/\u003e\n\u003cCallout title=\"var와 const, let의 차이\"\u003e\nvar는 변수 선언이 수집됨과 동시에 undefined로 초기화 되기 때문에 변수 선언문 전에 해당 변수에 접근이 가능했습니다. 이런 예기치 못한 동작을 보완하기 위해 나온 const, let은 선언문 이전에 변수가 초기화 되지 않는데요. 코드가 실행됨에 따라 변수 선언문에 도달했을 때 비로소 변수가 초기화되고 LexicalEnvironment가 업데이트 됩니다. 따라서 세 가지 키워드로 선언된 변수 모두 호이스팅 현상이 발생하지만 const, let은 변수 수집 후 초기화 되기 이전 영역인 TMZ(일시적 사각지대)에서는 변수에 접근할 수 없기 때문에 변수 선언문 이전에 접근할 수 없게 되는 것이죠.\n\u003c/Callout\u003e\n\u003cbr/\u003e\n\u003cCallout icon=\"🤔\" title=\"블록은 어떻게 스코프를 생성할까?\"\u003e\n실행 컨텍스트는 함수 호출 시에 생성된다고 이야기 했습니다. 그렇다면 블록에서는 어떻게 스코프가 만들어질까요? 바로 블록 코드가 실행될 때 LexicalEnvironment가 생성되기 떄문입니다. 이를 통해 블록 내부 식별자를 관리하고 스코프 체인을 통해 외부 환경의 식별자에도 접근할 수 있게 됩니다. 그리고 블록 내의 코드가 모두 종료 되었을 때 LexicalEnvironment가 제거됩니다.\n\u003c/Callout\u003e\n\u003cbr/\u003e\n### - ThisBinding(This 바인딩)\n\u003cbr/\u003e\n**This Binding**은 **this**의 값을 결정하는 정보로, 함수 호출 시 **this**가 참조할 객체를 결정합니다.\n\u003cbr/\u003e\n## 포스팅을 마무리하며\n\u003cbr/\u003e\n이렇게 자바스크립트 코드가 실행될 때의 환경 정보인 실행 컨텍스트에 대해서 알아보았습니다. 이를 통해 호이스팅, 스코프 체이닝, this 바인딩 등 자바스크립트에서 발생하는 다양한 현상들에 대해 이해할 수 있었습니다. 이번 포스팅을 통해 원래 그런 것, 그냥 그런 것은 없다는 사실도 다시끔 느끼게 되었네요.  \n\u003cbr/\u003e\n사실 실행 컨텍스트는 블로그를 시작하며 언젠가 꼭 다뤄야지 했던 주제입니다. 처음 변수 포스팅을 할 때도 '아 이걸 설명하려면 실행 컨텍스트 이야기를 해야하는데' 하면서 어디부터 어디까지 이야기해야하나 참 고민이 많았는데 이렇게 포스팅할 수 있게 되어서 숙제를 덜어낸 기분입니다. 그럼 후련한 마음으로 글을 마무리 하도록 하겠습니다. 여기까지 긴 글 읽어주셔서 감사합니다.😊","title":"실행 컨텍스트란?","intro":"이전에 변수 이야기를 하며 호이스팅, 스코프 체인 이야기를 언급했는데요. 왜 그런 현상이 일어나는지 궁금하지 않으셨나요? 실행 컨텍스트를 알게 되면 많은 궁금증이 풀리게 됩니다. 얼른 실행 컨텍스트에 대해 알아보러 갑시다.","isFeatured":true,"createdAt":"2024-08-12","thumbnail":"https://drive.google.com/uc?export=view\u0026id=159jGroEmKvVBVvLL9C77eprzuvnbccBn","keywords":"자바스크립트, javascript, 실행 컨텍스트, execution context, call stack, hoisting, scope"},"mdx":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    h2: \"h2\",\n    p: \"p\",\n    strong: \"strong\",\n    h3: \"h3\",\n    pre: \"pre\",\n    code: \"code\",\n    blockquote: \"blockquote\",\n    ol: \"ol\",\n    li: \"li\",\n    h4: \"h4\"\n  }, _provideComponents(), props.components), {Spacing, Callout, PostImage} = _components;\n  if (!Callout) _missingMdxReference(\"Callout\", true);\n  if (!PostImage) _missingMdxReference(\"PostImage\", true);\n  if (!Spacing) _missingMdxReference(\"Spacing\", true);\n  return _jsxs(_Fragment, {\n    children: [_jsx(\"p\", {\n      children: intro\n    }), \"\\n\", _jsx(Spacing, {\n      size: \"lg\"\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"실행 컨텍스트란?\"\n    }), \"\\n\", _jsx(\"br\", {}), \"\\n\", _jsxs(_components.p, {\n      children: [\"실행 컨텍스트란 코드를 실행할 때 필요한 문맥을 의미합니다. 글을 읽을 때 문맥을 파악하라는 말을 자주 하죠? 어휘의 의미와 문장의 앞 뒤 상황을 이해하여 글의 흐름을 파악하라는 말인데요. 실행 컨텍스트도 이와 비슷합니다. \", _jsx(_components.strong, {\n        children: \"실행 컨텍스트는 코드의 실행과 관련된 환경 정보\"\n      }), \"입니다. 이를 통해 현재 실행되는 코드 내의 식별자 정보와 외부 환경 참조, 함수 실행 순서 등을 관리하게 되는 것이죠.\"]\n    }), \"\\n\", _jsx(\"br\", {}), \"\\n\", _jsx(_components.h2, {\n      children: \"실행 컨텍스트의 생성/제거 시점\"\n    }), \"\\n\", _jsx(\"br\", {}), \"\\n\", _jsx(_components.p, {\n      children: \"실행 컨텍스트는 코드가 실행되기 전 생성되며, 코드 실행이 완료되면 제거됩니다.\\n자바스크립트 소스 코드 타입에 따른 실행 컨텍스트가 생성/제거 시점은 다음과 같습니다\"\n    }), \"\\n\", _jsx(\"br\", {}), \"\\n\", _jsx(_components.h3, {\n      children: \"- 전역 코드\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"함수, 코드 블럭 외부의 코드로 코드가 처음 실행될 때 컨텍스트가 생성되고 페이지가 종료될 때까지 유지됩니다.\"\n    }), \"\\n\", _jsx(\"br\", {}), \"\\n\", _jsx(_components.h3, {\n      children: \"- 함수 코드\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"함수 내부에 존재하는 코드로 함수가 호출 될 때 컨텍스트가 생성되고 함수가 종료되는 시점에서 컨텍스트가 제거됩니다. if문, for문과 같은 문(statement)에서는 실행 컨텍스트가 생성되지 않습니다.\"\n    }), \"\\n\", _jsx(\"br\", {}), \"\\n\", _jsx(_components.h3, {\n      children: \"- eval 코드\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"문자열로 표현된 코드를 실행할 수 있게 해주는 \", _jsx(_components.strong, {\n        children: \"eval\"\n      }), \" 함수에 인수로 전달되어 실행되는 코드입니다. eval 함수가 호출될 때 컨텍스트가 생성되고, \", _jsx(_components.strong, {\n        children: \"eval\"\n      }), \" 함수가 실행한 코드가 종료되는 시점에 컨텍스트가 종료됩니다.\"]\n    }), \"\\n\", _jsx(\"br\", {}), \"\\n\", _jsx(Callout, {\n      icon: \"🚨\",\n      children: _jsx(_components.p, {\n        children: \"eval은 문자열로 입력받은 코드가 악의적인 내용을 포함하는 등 보안상 위험이 생길 수 있기에 사용을 지양하고 있습니다.\"\n      })\n    }), \"\\n\", _jsx(\"br\", {}), \"\\n\", _jsx(_components.h3, {\n      children: \"- module 코드\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"자바스크립트 module 내부에 존재하는 코드로 module이 import 되는 순간 컨텍스트가 생성되며 해당 모듈 코드가 종료될 때 컨텍스트가 제거됩니다.\"\n    }), \"\\n\", _jsx(\"br\", {}), \"\\n\", _jsx(_components.h2, {\n      children: \"콜 스택을 통한 함수 실행 순서 관리\"\n    }), \"\\n\", _jsx(\"br\", {}), \"\\n\", _jsxs(_components.p, {\n      children: [\"일단 콜 스택에 대해 알아보기 전에, 스택에 대해 알고 계시나요? 스택이란 후입선출(LIFO, Last In First Out) 방식의 자료구조를 의미합니다. 즉, \", _jsx(_components.strong, {\n        children: \"마지막에 들어온 데이터가 가장 먼저 나가게 되는 것\"\n      }), \"이죠.\"]\n    }), \"\\n\", _jsx(\"br\", {}), \"\\n\", _jsx(PostImage, {\n      src: \"https://drive.google.com/uc?export=view\u0026id=14L-2EurAc37t_OeTgtjXLR3eDdOuTTSe\",\n      alt: \"스택\",\n      width: \"375\",\n      height: \"439\"\n    }), \"\\n\", _jsx(\"br\", {}), \"\\n\", _jsx(_components.p, {\n      children: \"콜 스택은 자바스크립트에서 함수 호출 시 생성되는 실행 컨텍스트를 관리하는 스택 자료구조인데요. 함수가 호출될 때 마다 콜 스택에 호출된 함수의 실행 컨텍스트가 차곡차곡 쌓이게 됩니다. 이때 가장 위에 쌓인 실행 컨텍스트를 가진 함수가 가장 먼저 실행됩니다. 즉 가장 니중에 호출된 함수가 가장 먼저 실행되는 것이죠.\"\n    }), \"\\n\", _jsx(\"br\", {}), \"\\n\", _jsx(_components.p, {\n      children: \"함수 실행이 완료되면, 그 함수의 실행 컨텍스트는 콜 스택에서 제거되고 그 다음으로 쌓인 실행 컨텍스트의 함수가 실행됩니다. 이렇게 콜 스택을 통해 함수의 실행 순서를 보장하게 되는 것이죠.\"\n    }), \"\\n\", _jsx(\"br\", {}), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-javascript\",\n        children: \"\\nconsole.log(\\\"1. 전역 컨텍스트\\\");\\n\\nfunction outerFunc () {\\n\\tconsole.log(\\\"1. outerFunc 컨텍스트\\\");\\n\\t\\n\\tfunction innerFunc () {\\n\\t\\tconsole.log(\\\"2. innerFunc 컨텍스트\\\");\\n\\t}\\n\\t\\n\\tinnerFunc();\\n}\\n\\nouterFunc();\\n\\nconsole.log(\\\"4. 함수 실행 컨텍스트가 모두 제거 된 후 전역 컨텍스트만 call stack에 남음\\\");\\n\"\n      })\n    }), \"\\n\", _jsx(\"br\", {}), \"\\n\", _jsx(_components.p, {\n      children: \"위와 같은 코드가 있을 때 콜 스택에 컨텍스트가 쌓이는 과정을 보겠습니다.\"\n    }), \"\\n\", _jsx(\"br\", {}), \"\\n\", _jsx(PostImage, {\n      src: \"https://drive.google.com/uc?export=view\u0026id=1Fce2nPOfLqWtHkuYP-4kPc6vDcyZosRs\",\n      alt: \"실행 컨텍스트가 call stack에 쌓이는 과정\",\n      width: \"688\",\n      height: \"523\"\n    }), \"\\n\", _jsx(\"br\", {}), \"\\n\", _jsxs(_components.blockquote, {\n      children: [\"\\n\", _jsxs(_components.ol, {\n        children: [\"\\n\", _jsx(_components.li, {\n          children: \"전역 컨텍스트 생성 -\u003e 콜 스택에 쌓임 -\u003e 'console.log(\\\"1. 전역 컨텍스트\\\")' 실행\"\n        }), \"\\n\", _jsx(_components.li, {\n          children: \"outerFunc 호출 -\u003e outerFunc 실행 컨텍스트 생성 -\u003e 콜 스택에 쌓임 -\u003e 'console.log(\\\"2. outerFunc 컨텍스트\\\");' 실행\"\n        }), \"\\n\", _jsx(_components.li, {\n          children: \"innerFunc 호출 -\u003e innerFunc 실행 컨텍스트 생성 -\u003e 콜 스택에 쌓임 -\u003e 'console.log(\\\"3. innerFunc 컨텍스트\\\")' 실행\"\n        }), \"\\n\", _jsx(_components.li, {\n          children: \"innerFunc 함수 종료 -\u003e 콜 스택에서 제거.\"\n        }), \"\\n\", _jsx(_components.li, {\n          children: \"outerFunc로 복귀 -\u003e outerFunc 함수 종료 -\u003e 콜 스택에서 제거.\"\n        }), \"\\n\", _jsx(_components.li, {\n          children: \"전역 컨텍스트로 복귀 -\u003e console.log(\\\"4. 함수 실행 컨텍스트가 모두 제거 된 후 전역 컨텍스트만 call stack에 남음\\\"); 실행, 전역 컨테스트는 페이지가 종료될 때 까지 유지.\"\n        }), \"\\n\"]\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(\"br\", {}), \"\\n\", _jsx(_components.p, {\n      children: \"이와 같이 코드가 실행되다가 함수가 호출되면 해당 함수의 실행 컨텍스트가 콜스택에 쌓이게 되고 해당 함수가 실행됩니다. 함수가 종료되고 콜스택에서 제거되면 이전 컨텍스트의 함수가 이어서 실행되게 됩니다.\"\n    }), \"\\n\", _jsx(\"br\", {}), \"\\n\", _jsx(_components.h2, {\n      children: \"실행 컨텍스트에 담긴 정보\"\n    }), \"\\n\", _jsx(\"br\", {}), \"\\n\", _jsx(_components.p, {\n      children: \"그럼 이제 실행 컨텍스트에 어떤 정보가 담겨있을지 알아보도록 하겠습니다.\"\n    }), \"\\n\", _jsx(\"br\", {}), \"\\n\", _jsx(_components.h3, {\n      children: \"- VariableEnvironment (변수 환경)\"\n    }), \"\\n\", _jsx(\"br\", {}), \"\\n\", _jsx(_components.p, {\n      children: \"VariableEnvironment는 컨텍스트 생성 시의 식별자 정보와 외부 환경 참조 정보를 가지고 있습니다. 컨텍스트 생성 될 때 컨텍스트의 내의 식별자를 수집합니다. var의 경우 수집과 동시에 undefined로 초기화됩니다. 컨텍스트 생성 당시의 상태를 기억하며 코드 진행 중에 값이 변경되지 않습니다. LexicalEnvironment와 동일한 구조를 가지기 때문에 자세한 구조에 대해선 LexicalEnvironment에서 이야기 해보겠습니다.\"\n    }), \"\\n\", _jsx(\"br\", {}), \"\\n\", _jsx(_components.h3, {\n      children: \"- LexicalEnvironment (어휘적 환경)\"\n    }), \"\\n\", _jsx(\"br\", {}), \"\\n\", _jsx(_components.p, {\n      children: \"LexicalEnvironment 역시 식별자 정보와 외부 환경 참조 정보를 가지고 있습니다. 컨텍스트가 생성 될 시점에는 VariableEnvironment를 복사하기 때문에 값이 동일하지만 코드가 실행됨에 따라 식별자 정보를 업데이트 합니다. (const, let으로 선언한 변수의 초기화, 변수 값 할당, 재할당 등)\"\n    }), \"\\n\", _jsx(\"br\", {}), \"\\n\", _jsx(_components.h4, {\n      children: \"- environmentRecord (환경 기록)\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"컨텍스트 내에서 수집된 식별자 정보가 있습니다.\"\n    }), \"\\n\", _jsx(\"br\", {}), \"\\n\", _jsx(_components.h4, {\n      children: \"- outerEnvironmentReference (외부 환경 참조)\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"현재 실행 컨텍스트의 외부 환경을 참조하는 정보입니다. 현재 컨텍스트에 식별자가 존재하지 않을 경우 외부 스코프에서 식별자를 검색합니다. 이를 통해 상위 스코프의 식별자에 접근할 수 있는 것을 스코프체인이라고 합니다. 내부 함수에서는 외부 함수의 식별자를 참조할 수 있지만 외부 함수에서 내부 함수에 참조할 수 없는 이유이기도 합니다.\"\n    }), \"\\n\", _jsx(\"br\", {}), \"\\n\", _jsx(Callout, {\n      title: \"호이스팅\",\n      children: _jsxs(_components.p, {\n        children: [\"코드가 실행되기 전 식별자를 수집하는 과정에서 식별자가 코드의 상단으로 끌어올려진 것처럼 동작하는 호이스팅 현상이 발생하게 됩니다. 즉, 실제로 식별자가 코드 위로 끌어올려진 것이 아니라 \", _jsx(_components.strong, {\n          children: \"environmentRecord\"\n        }), \"에 수집된 식별자를 컨텍스트 내에서 접근할 수 있게 되는 것이죠. 이로인해 var를 사용한 변수 선언, 함수 선언문에 도달하지 않아도 해당 식별자에 접근할 수 있게 됩니다.\"]\n      })\n    }), \"\\n\", _jsx(\"br\", {}), \"\\n\", _jsx(Callout, {\n      title: \"var와 const, let의 차이\",\n      children: _jsx(_components.p, {\n        children: \"var는 변수 선언이 수집됨과 동시에 undefined로 초기화 되기 때문에 변수 선언문 전에 해당 변수에 접근이 가능했습니다. 이런 예기치 못한 동작을 보완하기 위해 나온 const, let은 선언문 이전에 변수가 초기화 되지 않는데요. 코드가 실행됨에 따라 변수 선언문에 도달했을 때 비로소 변수가 초기화되고 LexicalEnvironment가 업데이트 됩니다. 따라서 세 가지 키워드로 선언된 변수 모두 호이스팅 현상이 발생하지만 const, let은 변수 수집 후 초기화 되기 이전 영역인 TMZ(일시적 사각지대)에서는 변수에 접근할 수 없기 때문에 변수 선언문 이전에 접근할 수 없게 되는 것이죠.\"\n      })\n    }), \"\\n\", _jsx(\"br\", {}), \"\\n\", _jsx(Callout, {\n      icon: \"🤔\",\n      title: \"블록은 어떻게 스코프를 생성할까?\",\n      children: _jsx(_components.p, {\n        children: \"실행 컨텍스트는 함수 호출 시에 생성된다고 이야기 했습니다. 그렇다면 블록에서는 어떻게 스코프가 만들어질까요? 바로 블록 코드가 실행될 때 LexicalEnvironment가 생성되기 떄문입니다. 이를 통해 블록 내부 식별자를 관리하고 스코프 체인을 통해 외부 환경의 식별자에도 접근할 수 있게 됩니다. 그리고 블록 내의 코드가 모두 종료 되었을 때 LexicalEnvironment가 제거됩니다.\"\n      })\n    }), \"\\n\", _jsx(\"br\", {}), \"\\n\", _jsx(_components.h3, {\n      children: \"- ThisBinding(This 바인딩)\"\n    }), \"\\n\", _jsx(\"br\", {}), \"\\n\", _jsxs(_components.p, {\n      children: [_jsx(_components.strong, {\n        children: \"This Binding\"\n      }), \"은 \", _jsx(_components.strong, {\n        children: \"this\"\n      }), \"의 값을 결정하는 정보로, 함수 호출 시 \", _jsx(_components.strong, {\n        children: \"this\"\n      }), \"가 참조할 객체를 결정합니다.\"]\n    }), \"\\n\", _jsx(\"br\", {}), \"\\n\", _jsx(_components.h2, {\n      children: \"포스팅을 마무리하며\"\n    }), \"\\n\", _jsx(\"br\", {}), \"\\n\", _jsx(_components.p, {\n      children: \"이렇게 자바스크립트 코드가 실행될 때의 환경 정보인 실행 컨텍스트에 대해서 알아보았습니다. 이를 통해 호이스팅, 스코프 체이닝, this 바인딩 등 자바스크립트에서 발생하는 다양한 현상들에 대해 이해할 수 있었습니다. 이번 포스팅을 통해 원래 그런 것, 그냥 그런 것은 없다는 사실도 다시끔 느끼게 되었네요.\"\n    }), \"\\n\", _jsx(\"br\", {}), \"\\n\", _jsx(_components.p, {\n      children: \"사실 실행 컨텍스트는 블로그를 시작하며 언젠가 꼭 다뤄야지 했던 주제입니다. 처음 변수 포스팅을 할 때도 '아 이걸 설명하려면 실행 컨텍스트 이야기를 해야하는데' 하면서 어디부터 어디까지 이야기해야하나 참 고민이 많았는데 이렇게 포스팅할 수 있게 되어서 숙제를 덜어낸 기분입니다. 그럼 후련한 마음으로 글을 마무리 하도록 하겠습니다. 여기까지 긴 글 읽어주셔서 감사합니다.😊\"\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, props)\n  })) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\nfunction _missingMdxReference(id, component) {\n  throw new Error(\"Expected \" + (component ? \"component\" : \"object\") + \" `\" + id + \"` to be defined: you likely forgot to import, pass, or provide it.\");\n}\n","frontmatter":{},"scope":{}}},"__N_SSG":true},"page":"/posts/[category]/[slug]","query":{"category":"Javascript","slug":"실행-컨텍스트란"},"buildId":"D2kP1jcyZ981G6yj10vNT","assetPrefix":"/dev-log","isFallback":false,"dynamicIds":[74237,38452,11925,79814,92703],"gsp":true,"scriptLoader":[]}</script></body></html>