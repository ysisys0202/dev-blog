<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><title>var는 왜 더이상 사용되지 않을까 | Yun&#x27;s Dev Log</title><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><meta http-equiv="X-UA-Compatible" content="IE=edge"/><meta name="keywords" content="자바스크립트, javascript, 변수, variables, var, const, let, hoisting, 호이스팅, scope"/><meta name="description" content="2024-07-24"/><meta property="og:title" content="var는 왜 더이상 사용되지 않을까"/><meta property="og:description" content="2024-07-24"/><meta property="og:image" content="https://drive.google.com/uc?export=view&amp;id=1KhO3x8PP7eh40G3ux4RsEg40L32eVkuC"/><meta name="next-head-count" content="10"/><link rel="icon" href="/favicon/favicon.ico" sizes="any"/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/dev-log/_next/static/chunks/polyfills-78c92fac7aa8fdd8.js"></script><script src="/scripts/controlColorTheme.js" defer="" data-nscript="beforeInteractive"></script><script defer="" src="/dev-log/_next/static/chunks/237.f617120547efd146.js"></script><script defer="" src="/dev-log/_next/static/chunks/181.caa4158faff447ce.js"></script><script defer="" src="/dev-log/_next/static/chunks/703.f3e679770b665ca2.js"></script><script defer="" src="/dev-log/_next/static/chunks/675-13fd5e310eff19b0.js"></script><script defer="" src="/dev-log/_next/static/chunks/814.97619cc949df0a7c.js"></script><script defer="" src="/dev-log/_next/static/chunks/925.d1147afb5fb2fa7d.js"></script><script defer="" src="/dev-log/_next/static/chunks/711.5a59ae5e423ac54a.js"></script><script src="/dev-log/_next/static/chunks/webpack-dcbb21c87370b2d0.js" defer=""></script><script src="/dev-log/_next/static/chunks/framework-5866cead997b9ace.js" defer=""></script><script src="/dev-log/_next/static/chunks/main-34080fb2c09c2911.js" defer=""></script><script src="/dev-log/_next/static/chunks/pages/_app-aba757bda1cadccf.js" defer=""></script><script src="/dev-log/_next/static/chunks/664-2bebff42daeb5deb.js" defer=""></script><script src="/dev-log/_next/static/chunks/473-f1052ffcd80437d7.js" defer=""></script><script src="/dev-log/_next/static/chunks/pages/posts/%5Bcategory%5D/%5Bslug%5D-b66fd9054f440daf.js" defer=""></script><script src="/dev-log/_next/static/D2kP1jcyZ981G6yj10vNT/_buildManifest.js" defer=""></script><script src="/dev-log/_next/static/D2kP1jcyZ981G6yj10vNT/_ssgManifest.js" defer=""></script></head><body><div id="__next"><style data-emotion="css-global dvgpy8">:root{--color-primary:#262626;--color-secondary:#404040;--color-tertiary:#525252;--color-background-element:#e5e5e5;--color-background-global:#fff;--color-border:#e5e5e5;}:root .dark{--color-primary:#f5f5f5;--color-secondary:#e5e5e5;--color-tertiary:#d4d4d4;--color-background-element:#404040;--color-background-global:#262626;--color-border:#737373;}html,body,div,span,applet,object,iframe,h1,h2,h3,h4,h5,h6,p,blockquote,pre,a,abbr,acronym,address,big,cite,code,del,dfn,em,img,ins,kbd,q,s,samp,small,strike,strong,sub,sup,tt,var,b,u,i,center,dl,dt,dd,ol,ul,li,fieldset,form,label,legend,table,caption,tbody,tfoot,thead,tr,th,td,article,aside,canvas,details,embed,figure,figcaption,footer,header,hgroup,menu,nav,output,ruby,section,summary,time,mark,audio,video,button{margin:0;padding:0;border:0;vertical-align:baseline;box-sizing:border-box;}article,aside,details,figcaption,figure,footer,header,hgroup,menu,nav,section{display:block;}body{line-height:1;}blockquote,q{quotes:none;}blockquote:before,blockquote:after,q:before,q:after{content:"";content:none;}table{border-collapse:collapse;border-spacing:0;}ol,ul{list-style:none;}a,button{cursor:pointer;}button{border:none;outline:none;background-color:transparent;font-size:inherit;font-weight:inherit;line-height:inherit;color:inherit;}a{-webkit-text-decoration:none;text-decoration:none;color:inherit;}@import url("https://cdn.jsdelivr.net/gh/orioncactus/pretendard@v1.3.9/dist/web/variable/pretendardvariable.min.css");html{font-size:16px;}@media (min-width: 1080px){html{font-size:18px;}}body{background-color:var(--color-background-global);color:var(--color-secondary);font-family:"Pretendard Variable",Pretendard,-apple-system,BlinkMacSystemFont,system-ui,Roboto,"Helvetica Neue","Segoe UI","Apple SD Gothic Neo","Noto Sans KR","Malgun Gothic","Apple Color Emoji","Segoe UI Emoji","Segoe UI Symbol",sans-serif;font-weight:400;line-height:1.6;letter-spacing:0.00938em;}.visually-hidden{position:absolute!important;width:1px!important;height:1px!important;padding:0!important;margin:-1px!important;overflow:hidden!important;clip:rect(0, 0, 0, 0)!important;white-space:nowrap!important;border:0!important;}</style><div class="css-0"><style data-emotion="css zuuo44">.css-zuuo44{width:100%;}@media (min-width: 1080px){.css-zuuo44{margin-left:auto;width:80%;max-width:calc(100% - 220px);}}</style><div class="css-zuuo44"><style data-emotion="css qo0yyd">.css-qo0yyd{position:-webkit-sticky;position:sticky;top:0;right:0;z-index:50;padding:0 20px;width:100%;height:52px;background-color:rgba(255, 255, 255, 0.2);border-bottom:1px solid var(--color-border);-webkit-backdrop-filter:blur(10px);backdrop-filter:blur(10px);-webkit-transition:-webkit-transform 200ms ease-in-out;transition:transform 200ms ease-in-out;}.css-qo0yyd.is-hide{-webkit-transform:translateY(-100%);-moz-transform:translateY(-100%);-ms-transform:translateY(-100%);transform:translateY(-100%);}@media (min-width: 1080px){.css-qo0yyd{height:56px;}}</style><header class=" css-qo0yyd"><style data-emotion="css 1uwonur">.css-1uwonur{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-box-pack:justify;-webkit-justify-content:space-between;justify-content:space-between;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;}</style><nav class="css-1uwonur"><h2 class="visually-hidden">블로그 대메뉴</h2><style data-emotion="css guxf6x">.css-guxf6x{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;}</style><ul class="css-guxf6x"><style data-emotion="css 3rt8qm">.css-3rt8qm a{display:inline-block;position:relative;padding:12px;}.css-3rt8qm a::after{content:"";position:absolute;bottom:0;left:0;width:100%;height:2px;background-color:transparent;}.css-3rt8qm.is-active a::after{background-color:var(--color-secondary);}</style><li class=" css-3rt8qm"><a href="/dev-log"><style data-emotion="css 1gs3x7d">.css-1gs3x7d{line-height:1.6;letter-spacing:0.00938em;font-size:18px;font-size:700;color:var(--color-primary);}.css-1gs3x7d[class^="typography-h"],.css-1gs3x7d[class^="typography-subtitle"]{font-weight:600;}.css-1gs3x7d[class^="typography-body"]{font-weight:400;}@media (min-width: 1080px){.css-1gs3x7d{font-size:20px;}}</style><span class="typography-subtitle1  css-1gs3x7d">홈</span></a></li><li class=" css-3rt8qm"><a href="/dev-log/posts"><span class="typography-subtitle1  css-1gs3x7d">게시글 목록</span></a></li></ul></nav></header><style data-emotion="css 94ewza">.css-94ewza{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;gap:12px;position:fixed;top:0;right:16px;z-index:100;height:52px;}@media (min-width: 1080px){.css-94ewza{right:32;height:56px;}}</style><div class="css-94ewza"><style data-emotion="css dj5yub">.css-dj5yub{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-box-pack:center;-ms-flex-pack:center;-webkit-justify-content:center;justify-content:center;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;}.css-dj5yub svg{width:24px;height:24px;}</style><button aria-label="다크모드로 변경하기" class="css-dj5yub"><svg width="24" height="24" viewBox="0 0 24 24" fill="var(--color-primary)" xmlns="http://www.w3.org/2000/svg"><path d="M19.9 2.307a.483.483 0 0 0-.9 0l-.43 1.095a.484.484 0 0 1-.272.274l-1.091.432a.486.486 0 0 0 0 .903l1.091.432c.125.049.223.148.272.273L19 6.81c.162.41.74.41.9 0l.43-1.095a.484.484 0 0 1 .273-.273l1.091-.432a.486.486 0 0 0 0-.903l-1.091-.432a.484.484 0 0 1-.273-.274l-.43-1.095ZM16.033 8.13a.483.483 0 0 0-.9 0l-.157.399a.484.484 0 0 1-.272.273l-.398.158a.486.486 0 0 0 0 .903l.398.157c.125.05.223.148.272.274l.157.399c.161.41.739.41.9 0l.157-.4a.484.484 0 0 1 .272-.273l.398-.157a.486.486 0 0 0 0-.903l-.398-.158a.484.484 0 0 1-.272-.273l-.157-.4Z" fill="current"></path><path d="M12 22c5.523 0 10-4.477 10-10 0-.463-.694-.54-.933-.143a6.5 6.5 0 1 1-8.924-8.924C12.54 2.693 12.463 2 12 2 6.477 2 2 6.477 2 12s4.477 10 10 10Z" fill="current"></path></svg><span class="visually-hidden">다크모드로 변경하기</span></button><a href="mailto:ysisys0202@gmail.com"><div aria-label="이메일 보기" class="css-dj5yub"><svg width="24" height="24" viewBox="0 0 48 48" xmlns="http://www.w3.org/2000/svg" fill="var(--color-primary)"><path d="M0 0h48v48H0z" fill="none"></path><path d="M24 44c5.343 0 10.365-2.08 14.143-5.858l-2.829-2.828A15.895 15.895 0 0 1 24 40c-8.822 0-16-7.178-16-16S15.178 8 24 8s16 7.178 16 16c0 2.206-1.794 4-4 4s-4-1.794-4-4v-8h-4v1.079A7.955 7.955 0 0 0 24 16a8 8 0 0 0 0 16 7.976 7.976 0 0 0 6.003-2.723A7.975 7.975 0 0 0 36 32c4.411 0 8-3.589 8-8 0-11.028-8.972-20-20-20S4 12.972 4 24s8.972 20 20 20zm0-16c-2.206 0-4-1.794-4-4s1.794-4 4-4 4 1.794 4 4-1.794 4-4 4z"></path></svg><span class="visually-hidden">이메일 보기</span></div></a></div><main><style data-emotion="css tgaap8">.css-tgaap8{padding:32px 24px 80px;}@media (min-width: 1080px){.css-tgaap8{padding:48px 24px 80px;width:80%;max-width:calc(100% - 230px);}}@media (min-width: 1320px){.css-tgaap8{padding:48px 56px 80px;max-width:860px;}}</style><div id="post-container" class="css-tgaap8"><style data-emotion="css 12u75z1">.css-12u75z1{margin-top:24px;}@media (min-width: 1080px){.css-12u75z1{margin-top:32px;}}</style><article class="css-12u75z1"><style data-emotion="css 1bh2vrl">.css-1bh2vrl{padding-bottom:48px;}</style><header class="css-1bh2vrl"><div><a href="/dev-log/posts/Javascript"><style data-emotion="css 11miuq7">.css-11miuq7{display:-webkit-inline-box;display:-webkit-inline-flex;display:-ms-inline-flexbox;display:inline-flex;-webkit-box-pack:center;-ms-flex-pack:center;-webkit-justify-content:center;justify-content:center;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;border-radius:20px;padding:4px 12px;font-size:12px;line-height:1.4;border:1px solid;background-color:transparent;color:var(--color-primary);border-color:var(--color-primary);}</style><div class="css-11miuq7">Javascript</div></a><style data-emotion="css 1d8q2lt">.css-1d8q2lt{margin-top:8px;}</style><style data-emotion="css 168di4w">.css-168di4w{line-height:1.6;letter-spacing:0.00938em;font-size:32px;color:var(--color-primary);margin-top:8px;}.css-168di4w[class^="typography-h"],.css-168di4w[class^="typography-subtitle"]{font-weight:600;}.css-168di4w[class^="typography-body"]{font-weight:400;}@media (min-width: 1080px){.css-168di4w{font-size:36px;}}</style><h1 class="typography-h1 css-168di4w">var는 왜 더이상 사용되지 않을까</h1><style data-emotion="css ems5xl">.css-ems5xl{margin-top:4px;}</style><style data-emotion="css 1675m0x">.css-1675m0x{line-height:1.6;letter-spacing:0.00938em;font-size:18px;font-size:700;color:var(--color-primary);margin-top:4px;}.css-1675m0x[class^="typography-h"],.css-1675m0x[class^="typography-subtitle"]{font-weight:600;}.css-1675m0x[class^="typography-body"]{font-weight:400;}@media (min-width: 1080px){.css-1675m0x{font-size:20px;}}</style><p class="typography-subtitle1 css-1675m0x">var와 const, let의 차이점 알아보기</p><style data-emotion="css 16kssqz">.css-16kssqz{margin-top:4px;}</style><div class="css-16kssqz"><style data-emotion="css hij6lw">.css-hij6lw::after{content:":";margin:0 4px;}</style><style data-emotion="css 1k2vjrr">.css-1k2vjrr{line-height:1.6;letter-spacing:0.00938em;font-size:14px;color:var( --color-tertiary);}.css-1k2vjrr[class^="typography-h"],.css-1k2vjrr[class^="typography-subtitle"]{font-weight:600;}.css-1k2vjrr[class^="typography-body"]{font-weight:400;}@media (min-width: 1080px){.css-1k2vjrr{font-size:15px;}}.css-1k2vjrr::after{content:":";margin:0 4px;}</style><span class="typography-body2 css-1k2vjrr">최종 수정일</span><style data-emotion="css 1dhx26">.css-1dhx26{line-height:1.6;letter-spacing:0.00938em;font-size:14px;color:var( --color-tertiary);}.css-1dhx26[class^="typography-h"],.css-1dhx26[class^="typography-subtitle"]{font-weight:600;}.css-1dhx26[class^="typography-body"]{font-weight:400;}@media (min-width: 1080px){.css-1dhx26{font-size:15px;}}</style><span class="typography-body2 value css-1dhx26">2024년 7월 24일</span></div></div></header><style data-emotion="css d3ymdl">.css-d3ymdl{word-break:keep-all;}.css-d3ymdl p{white-space:pre-wrap;}.css-d3ymdl del{font-size:14px;color:var( --color-tertiary);}.css-d3ymdl table{background-color:var(--color-background-global);}.css-d3ymdl table thead{border-bottom:2px solid var(--color-border);}.css-d3ymdl table th,.css-d3ymdl table td{padding:10px 16px;border:1px solid var(--color-border);}.css-d3ymdl a{-webkit-text-decoration:underline;text-decoration:underline;}.css-d3ymdl a::after{content:"↗️";font-size:0.6em;}.css-d3ymdl ol{list-style:decimal;}.css-d3ymdl ul{list-style:disc;}.css-d3ymdl li{margin-left:16px;}.css-d3ymdl li:not(:first-of-type){margin-top:8px;}.css-d3ymdl blockquote{position:relative;padding:12px 24px;background-color:var(--color-background-element);font-size:15px;}@media (min-width: 1080px){.css-d3ymdl blockquote{font-size:16px;}}.css-d3ymdl blockquote::before{content:"";position:absolute;top:0;left:0;width:4px;height:100%;background-color:var(--color-primary);}</style><div class="css-d3ymdl"><p>혹시 자바스크립트에서 var 사용을 지양하라는 말을 들어보셨나요? 
 var는 한때 자바스크립트에서 변수를 선언할 수 있는 유일한 키워드였습니다. 하지만 ES6부터 모던 자바스크립트를 사용하는 개발자들은 더 이상 var를 사용하지 않고 있습니다. ES6부터 포함된 const와 let이라는 변수 선언 키워드가 있기 때문입니다. 하지만 var를 사용하지 않는 이유가 그저 오래된 문법이라서일까요? var와 const, let의 차이점을 알아보며 var가 외면받는 이유에 대해 알아보겠습니다.</p>
<style data-emotion="css 1cwv52n">.css-1cwv52n{height:24px;background-color:transparent;}</style><div aria-hidden="false" class="css-1cwv52n"></div>
<style data-emotion="css f925jc">.css-f925jc{line-height:1.6;letter-spacing:0.00938em;font-size:22px;color:var(--color-primary);}.css-f925jc[class^="typography-h"],.css-f925jc[class^="typography-subtitle"]{font-weight:600;}.css-f925jc[class^="typography-body"]{font-weight:400;}@media (min-width: 1080px){.css-f925jc{font-size:28px;}}</style><h2 class="typography-h3  css-f925jc" id="프로그래밍에서-변수란">프로그래밍에서 변수란?</h2>
<br/>
<p>프로그래밍에서 변수란 <strong>하나의 값을 저장하기 위해 이름이 붙은 메모리 공간</strong>을 뜻합니다.</p>
<br/>
<pre><section><style data-emotion="css 19ewdi0">.css-19ewdi0{padding:8px;border-radius:4px 4px 0 0;background-color:#a3a3a3;}</style><header class="css-19ewdi0"><style data-emotion="css 1fte3e1">.css-1fte3e1{line-height:1.6;letter-spacing:0.00938em;font-size:16px;}.css-1fte3e1[class^="typography-h"],.css-1fte3e1[class^="typography-subtitle"]{font-weight:600;}.css-1fte3e1[class^="typography-body"]{font-weight:400;}@media (min-width: 1080px){.css-1fte3e1{font-size:18px;}}</style><span class="typography-body1  css-1fte3e1">javascript</span></header><style data-emotion="css 4iulct">.css-4iulct{margin:0!important;}</style><pre class="css-4iulct" style="text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;color:#eee;background:#2f2f2f;font-family:Roboto Mono, monospace;font-size:1em;line-height:1.5em;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;overflow:auto;position:relative;margin:0.5em 0;padding:1.25em 1em"><code class="language-javascript" style="text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;color:#eee;background:#2f2f2f;font-family:Roboto Mono, monospace;font-size:1em;line-height:1.5em;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none"><span class="token token" style="color:#c792ea">var</span><span> password </span><span class="token token" style="color:#89ddff">=</span><span> </span><span class="token token" style="color:#fd9170">123456</span><span class="token token" style="color:#89ddff">;</span><span> 
</span></code></pre></section></pre>
<br/>
<p>위와 같이 변수를 선언하고 값을 할당하면 3단계에 걸쳐 변수에 값이 저장됩니다.</p>
<br/>
<div><style data-emotion="css 11z8347">.css-11z8347{max-width:100%;height:auto;}</style><img alt="변수 선언 과정" loading="lazy" width="580" height="392" decoding="async" data-nimg="1" class="css-11z8347" style="color:transparent" srcSet="?url=https%3A%2F%2Fdrive.google.com%2Fuc%3Fexport%3Dview%26id%3D1WtfApWevV7lzHhaKIx6mF-KktJy5wZBo&amp;w=640&amp;q=75 1x, ?url=https%3A%2F%2Fdrive.google.com%2Fuc%3Fexport%3Dview%26id%3D1WtfApWevV7lzHhaKIx6mF-KktJy5wZBo&amp;w=1200&amp;q=75 2x" src="?url=https%3A%2F%2Fdrive.google.com%2Fuc%3Fexport%3Dview%26id%3D1WtfApWevV7lzHhaKIx6mF-KktJy5wZBo&amp;w=1200&amp;q=75"/></div>
<br/>
<blockquote>
<ol>
<li>선언 : 자바스크립트 엔진이 <strong>변수의 식별자를 인식하는 단계</strong>입니다. 식별자만 인식할 뿐 값이 저장되지는 않습니다.</li>
<li>초기화 : 변수 식별자가 인식된 후, <strong>메모리 공간을 확보하고 초기값을 설정하는 단계</strong>입니다. 이 때 식별자는 확보된 메모리 공간의 주소값을 가르킵니다. 초기 값이 명시되어 있지 않은 경우 undefined로 초기화 됩니다.</li>
<li>할당 : 식별자가 가르키고 있는 주소의 <strong>메모리 공간에 값을 저장하는 단계</strong>입니다.</li>
</ol>
</blockquote>
<br/>
<h2 class="typography-h3  css-f925jc" id="var와-const-let의-차이">var와 const, let의 차이</h2>
<br/>
<p>이제 자바스크립트에서 변수를 선언할 때 사용하는 세가지 키워드 var와 const,let의 차이점에 대해 알아봅시다.</p>
<br/>
<style data-emotion="css 1f3zz6o">.css-1f3zz6o{line-height:1.6;letter-spacing:0.00938em;font-size:20px;color:var(--color-primary);}.css-1f3zz6o[class^="typography-h"],.css-1f3zz6o[class^="typography-subtitle"]{font-weight:600;}.css-1f3zz6o[class^="typography-body"]{font-weight:400;}@media (min-width: 1080px){.css-1f3zz6o{font-size:24px;}}</style><h3 class="typography-h4  css-1f3zz6o" id="-재선언-재할당-가능-여부">1. 재선언 , 재할당 가능 여부</h3>
<br/>
<h4 class="typography-subtitle1  css-1gs3x7d" id="재선언과-재할당이란">재선언과 재할당이란?</h4>
<br/>
<p><strong>재선언</strong> : 이미 선언된 변수 식별자를 다시 사용하여 변수를 선언하는 것을 의미합니다.</p>
<br/>
<pre><section><header class="css-19ewdi0"><span class="typography-body1  css-1fte3e1">javascript</span></header><pre class="css-4iulct" style="text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;color:#eee;background:#2f2f2f;font-family:Roboto Mono, monospace;font-size:1em;line-height:1.5em;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;overflow:auto;position:relative;margin:0.5em 0;padding:1.25em 1em"><code class="language-javascript" style="text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;color:#eee;background:#2f2f2f;font-family:Roboto Mono, monospace;font-size:1em;line-height:1.5em;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none"><span class="token token" style="color:#c792ea">var</span><span> password </span><span class="token token" style="color:#89ddff">=</span><span> </span><span class="token token" style="color:#fd9170">123456</span><span class="token token" style="color:#89ddff">;</span><span> 
</span><span></span><span class="token token" style="color:#c792ea">var</span><span> password </span><span class="token token" style="color:#89ddff">=</span><span> </span><span class="token token" style="color:#fd9170">654321</span><span class="token token" style="color:#89ddff">;</span><span> </span><span class="token token" style="color:#616161">// 이미 사용된 password 식별자를 사용하여 변수를 재선언</span><span>
</span>
<span></span><span class="token token console" style="color:#f2ff00">console</span><span class="token token" style="color:#89ddff">.</span><span class="token token method property-access" style="color:#c792ea">log</span><span class="token token" style="color:#89ddff">(</span><span class="token token" style="color:#fd9170">654321</span><span class="token token" style="color:#89ddff">)</span><span class="token token" style="color:#89ddff">;</span><span> </span><span class="token token" style="color:#616161">// 재선언 시 할당된 654321이 출력된다.</span><span>
</span></code></pre></section></pre>
<br/>
<p><strong>재할당</strong> : 변수에 값을 다시 할당하는 것을 의미합니다.</p>
<br/>
<pre><section><header class="css-19ewdi0"><span class="typography-body1  css-1fte3e1">javascript</span></header><pre class="css-4iulct" style="text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;color:#eee;background:#2f2f2f;font-family:Roboto Mono, monospace;font-size:1em;line-height:1.5em;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;overflow:auto;position:relative;margin:0.5em 0;padding:1.25em 1em"><code class="language-javascript" style="text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;color:#eee;background:#2f2f2f;font-family:Roboto Mono, monospace;font-size:1em;line-height:1.5em;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none"><span class="token token" style="color:#c792ea">var</span><span> password </span><span class="token token" style="color:#89ddff">=</span><span> </span><span class="token token" style="color:#fd9170">123456</span><span class="token token" style="color:#89ddff">;</span><span> 
</span><span>password </span><span class="token token" style="color:#89ddff">=</span><span> </span><span class="token token" style="color:#fd9170">654321</span><span class="token token" style="color:#89ddff">;</span><span> </span><span class="token token" style="color:#616161">// password 값에 값을 재할당</span><span>
</span>
<span></span><span class="token token console" style="color:#f2ff00">console</span><span class="token token" style="color:#89ddff">.</span><span class="token token method property-access" style="color:#c792ea">log</span><span class="token token" style="color:#89ddff">(</span><span class="token token" style="color:#fd9170">654321</span><span class="token token" style="color:#89ddff">)</span><span class="token token" style="color:#89ddff">;</span><span> </span><span class="token token" style="color:#616161">// 재할당 된 654321 값이 출력된다.</span><span>
</span></code></pre></section></pre>
<br/>
<p>var와 const, let의 재선언, 재할당 여부는 아래와 같습니다.</p>
<br/>
<table><thead><tr><th>변수 선언 키워드</th><th>재선언</th><th>재할당</th></tr></thead><tbody><tr><td>var</td><td>O</td><td>O</td></tr><tr><td>const (ES6)</td><td>X</td><td>X</td></tr><tr><td>let (ES6)</td><td>X</td><td>O</td></tr></tbody></table>
<br/>
<ol>
<li><strong>var</strong> : 재선언과 재할당 <strong>모두 가능</strong>합니다.</li>
<li><strong>const</strong> : 재선언과 재할당 <strong>모두 불가능</strong>합니다. 값이 변하지 않으니, 선언과 동시에 값이 할당되어야 합니다. 재할당이 허용되지 않으므로 상수(constance)라고도 합니다.</li>
<li><strong>let</strong> : <strong>재할당만 가능</strong>하고 재선언은 허용되지 않습니다.</li>
</ol>
<br/>
<div><img alt="챗지피티한테 let의 의미를 물어보았다." loading="lazy" width="558" height="266" decoding="async" data-nimg="1" class="css-11z8347" style="color:transparent" srcSet="?url=https%3A%2F%2Fdrive.google.com%2Fuc%3Fexport%3Dview%26id%3D14fhjKXNkr4VFS8JnRq4UDa8c052BeEp9&amp;w=640&amp;q=75 1x, ?url=https%3A%2F%2Fdrive.google.com%2Fuc%3Fexport%3Dview%26id%3D14fhjKXNkr4VFS8JnRq4UDa8c052BeEp9&amp;w=1200&amp;q=75 2x" src="?url=https%3A%2F%2Fdrive.google.com%2Fuc%3Fexport%3Dview%26id%3D14fhjKXNkr4VFS8JnRq4UDa8c052BeEp9&amp;w=1200&amp;q=75"/><p class="typography-body2  css-1dhx26">그래서 let이 무슨 뜻이냐고요...</p></div>
<br/>
<h4 class="typography-subtitle1  css-1gs3x7d" id="재선언의-위험성-">재선언의 위험성 🚨</h4>
<br/>
<pre><section><header class="css-19ewdi0"><span class="typography-body1  css-1fte3e1">javascript</span></header><pre class="css-4iulct" style="text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;color:#eee;background:#2f2f2f;font-family:Roboto Mono, monospace;font-size:1em;line-height:1.5em;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;overflow:auto;position:relative;margin:0.5em 0;padding:1.25em 1em"><code class="language-javascript" style="text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;color:#eee;background:#2f2f2f;font-family:Roboto Mono, monospace;font-size:1em;line-height:1.5em;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none"><span class="token token" style="color:#c792ea">var</span><span> password </span><span class="token token" style="color:#89ddff">=</span><span> </span><span class="token token" style="color:#fd9170">123456</span><span class="token token" style="color:#89ddff">;</span><span> 
</span>
<span></span><span class="token token" style="color:#616161">// 1000 lines later ...🐌</span><span>
</span>
<span></span><span class="token token" style="color:#c792ea">var</span><span> password </span><span class="token token" style="color:#89ddff">=</span><span> </span><span class="token token" style="color:#fd9170">654321</span><span class="token token" style="color:#89ddff">;</span><span> 
</span><span></span><span class="token token" style="color:#616161">// 코드가 너무 길어져 실수로 위에 선언된 password를 덮어쓴다면?!😱</span><span>
</span></code></pre></section></pre>
<br/>
<p>위와 같이 코드가 길어지거나 다른 개발자와 협업하여 일하는 경우 기존에 변수가 재선언되어 덮어써진다면 생각지 못한 에러가 발생하겠죠? 이런 상황을 미연에 방지하기 위해 <strong>재선언을 허용하지 않는 키워드인 const와 let을 사용하는 것이 좋습니다.</strong></p>
<br/>
<h4 class="typography-subtitle1  css-1gs3x7d" id="어떤-상황에서-const를-쓰고-let을-써야할까요">어떤 상황에서 const를 쓰고 let을 써야할까요?🤔</h4>
<br/>
<p><strong>변수에 값을 재할당해야 할 이유가 없는 모든 경우에 const를 쓰는 것이 바람직합니다.</strong> const는 재할당조차 허용하지 않는 가장 엄격한 키워드이기 때문에 의도치 않게 값을 변경시키는 일이 발생하지 않기 때문입니다.</p>
<br/>
<pre><section><header class="css-19ewdi0"><span class="typography-body1  css-1fte3e1">javascript</span></header><pre class="css-4iulct" style="text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;color:#eee;background:#2f2f2f;font-family:Roboto Mono, monospace;font-size:1em;line-height:1.5em;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;overflow:auto;position:relative;margin:0.5em 0;padding:1.25em 1em"><code class="language-javascript" style="text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;color:#eee;background:#2f2f2f;font-family:Roboto Mono, monospace;font-size:1em;line-height:1.5em;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none"><span class="token token" style="color:#c792ea">const</span><span> password </span><span class="token token" style="color:#89ddff">=</span><span> </span><span class="token token" style="color:#fd9170">123456</span><span class="token token" style="color:#89ddff">;</span><span> 
</span>
<span>password </span><span class="token token" style="color:#89ddff">=</span><span> </span><span class="token token" style="color:#fd9170">654321</span><span class="token token" style="color:#89ddff">;</span><span> 
</span><span></span><span class="token token" style="color:#616161">// TypeError: Assignment to constant variable</span><span>
</span></code></pre></section></pre>
<br/>
<p>부득이하게 값이 재할당 되어야 할 때는 let을 사용하면 됩니다. 저는 주로 if문, switch문 같은 조건문에서 조건에 따라 값을 다르게 할당해야하는 경우에 사용했습니다.
(<del>만약문이라고 쓰고 5초간 뭐가 이상한지 몰랐던 사람이 바로 저예요</del>)</p>
<br/>
<h3 class="typography-h4  css-1f3zz6o" id="-스코프-scope">2. 스코프 (scope)</h3>
<br/>
<h4 class="typography-subtitle1  css-1gs3x7d" id="스코프란">스코프란?</h4>
<br/>
<p>스코프(scope)는 <strong>변수에 접근할 수 있는 유효 범위</strong>를 뜻합니다.<br/></p>
<br/>
<p><strong>전역 스코프 (Global Scope)</strong> : 함수나 블럭 바깥의 최상위 공간입니다. 전역 스코프에 선언된 변수는 어디서나 접근 가능하며 이를 전역 변수라고 합니다.
<strong>지역 스코프 (Local Scope)</strong> : 함수나 블럭 내부를 뜻합니다. 지역 스코프에 선언된 변수는 해당 스코프 내에서만 접근 가능하여 이를 지역 변수라고 합니다.</p>
<br/>
<div><img alt="스코프" loading="lazy" width="558" height="266" decoding="async" data-nimg="1" class="css-11z8347" style="color:transparent" srcSet="?url=https%3A%2F%2Fdrive.google.com%2Fuc%3Fexport%3Dview%26id%3D1ZAsj37PaM6f7rCxrv65DjyHeVz4BMqy_&amp;w=640&amp;q=75 1x, ?url=https%3A%2F%2Fdrive.google.com%2Fuc%3Fexport%3Dview%26id%3D1ZAsj37PaM6f7rCxrv65DjyHeVz4BMqy_&amp;w=1200&amp;q=75 2x" src="?url=https%3A%2F%2Fdrive.google.com%2Fuc%3Fexport%3Dview%26id%3D1ZAsj37PaM6f7rCxrv65DjyHeVz4BMqy_&amp;w=1200&amp;q=75"/></div>
<br/>
<blockquote>
<ol>
<li>전역 스코프에 선언된 변수는 어디서나 접근 가능합니다.</li>
<li>지역 스코프에 선언된 변수는 전역 스코프에서 접근할 수 없습니다.
<br/> (전역 스코프에서 outerFunction에 선언된 outerVar에 접근할 수 없음)</li>
<li>함수가 중첩된 경우 하위 함수에서는 상위 함수에 선언된 변수에 접근할 수 있지만 외부 함수에서 내부 함수에 선언된 변수에 접근할 수 없습니다.
<br/> (outerFunction에서 innerFunction에 선언된 innerVar에 접근할 수 없음)</li>
<li>변수에 접근할 때 함수 내부에 선언되지 않았다면 상위 스코프로 올라가서 찾습니다. (스코프 체인)
<br/> (innerFunction은 outerFunction, 전역 스코프에 있는 변수에 모두 접근이 가능)</li>
</ol>
</blockquote>
<br/>
<h4 class="typography-subtitle1  css-1gs3x7d" id="var와-const-let의-스코프-차이">var와 const, let의 스코프 차이</h4>
<br/>
<ul>
<li><strong>var의 스코프</strong> : <strong>함수 레벨</strong> (function level)</li>
<li><strong>const, let의 스코프</strong> : <strong>블럭 레벨</strong> (block level)</li>
</ul>
<br/>
<h4 class="typography-subtitle1  css-1gs3x7d" id="함수-스코프의-단점">함수 스코프의 단점</h4>
<br/>
<p>함수 선언 시에 블럭이 사용되니 둘이 비슷한 것이 아닌가? 라는 생각이 들수도 있지만 함수 레벨의 유효 범위에서는 if문, for문처럼 함수가 아닌 문(statement) 안에서 선언한 변수가 전역변수가 되어 코드 여기저기서 참조할 수 있게 될뿐더러 다른 변수와 충돌할 가능성이 있습니다. 때문에 <strong>안정적이고 예측 가능한 변수 사용을 위해 블록 스코프인 const와 let을 사용하는 것이 좋습니다.</strong></p>
<br/>
<pre><section><header class="css-19ewdi0"><span class="typography-body1  css-1fte3e1">javascript</span></header><pre class="css-4iulct" style="text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;color:#eee;background:#2f2f2f;font-family:Roboto Mono, monospace;font-size:1em;line-height:1.5em;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;overflow:auto;position:relative;margin:0.5em 0;padding:1.25em 1em"><code class="language-javascript" style="text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;color:#eee;background:#2f2f2f;font-family:Roboto Mono, monospace;font-size:1em;line-height:1.5em;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none"><span class="token token control-flow" style="color:#c792ea">for</span><span> </span><span class="token token" style="color:#89ddff">(</span><span class="token token" style="color:#c792ea">var</span><span> i </span><span class="token token" style="color:#89ddff">=</span><span> </span><span class="token token" style="color:#fd9170">0</span><span class="token token" style="color:#89ddff">;</span><span> i </span><span class="token token" style="color:#89ddff">&lt;</span><span> </span><span class="token token" style="color:#fd9170">10</span><span class="token token" style="color:#89ddff">;</span><span> i</span><span class="token token" style="color:#89ddff">++</span><span class="token token" style="color:#89ddff">)</span><span> </span><span class="token token" style="color:#89ddff">{</span><span>
</span><span>  </span><span class="token token" style="color:#c792ea">var</span><span> a </span><span class="token token" style="color:#89ddff">=</span><span> </span><span class="token token" style="color:#a5e844">&quot;a&quot;</span><span class="token token" style="color:#89ddff">;</span><span>
</span><span></span><span class="token token" style="color:#89ddff">}</span><span>
</span><span></span><span class="token token console" style="color:#f2ff00">console</span><span class="token token" style="color:#89ddff">.</span><span class="token token method property-access" style="color:#c792ea">log</span><span class="token token" style="color:#89ddff">(</span><span>i</span><span class="token token" style="color:#89ddff">)</span><span class="token token" style="color:#89ddff">;</span><span> </span><span class="token token" style="color:#616161">// 10 =&gt; 루프 헤더에 선언된 i에 접근 가능</span><span>
</span><span></span><span class="token token console" style="color:#f2ff00">console</span><span class="token token" style="color:#89ddff">.</span><span class="token token method property-access" style="color:#c792ea">log</span><span class="token token" style="color:#89ddff">(</span><span>a</span><span class="token token" style="color:#89ddff">)</span><span class="token token" style="color:#89ddff">;</span><span> </span><span class="token token" style="color:#616161">// &#x27;a&#x27; =&gt; for문 안에 선언된 a에도 접근 가능</span><span>
</span>
<span></span><span class="token token control-flow" style="color:#c792ea">if</span><span> </span><span class="token token" style="color:#89ddff">(</span><span class="token token" style="color:#c792ea">false</span><span class="token token" style="color:#89ddff">)</span><span> </span><span class="token token" style="color:#89ddff">{</span><span>
</span><span>  </span><span class="token token" style="color:#c792ea">var</span><span> b </span><span class="token token" style="color:#89ddff">=</span><span> </span><span class="token token" style="color:#a5e844">&quot;b&quot;</span><span class="token token" style="color:#89ddff">;</span><span>
</span><span></span><span class="token token" style="color:#89ddff">}</span><span>
</span>
<span></span><span class="token token console" style="color:#f2ff00">console</span><span class="token token" style="color:#89ddff">.</span><span class="token token method property-access" style="color:#c792ea">log</span><span class="token token" style="color:#89ddff">(</span><span>b</span><span class="token token" style="color:#89ddff">)</span><span class="token token" style="color:#89ddff">;</span><span> 
</span><span></span><span class="token token" style="color:#616161">// undefined =&gt; if문의 조건이 거짓이므로 값을 할당되지 않았지만 전역변수이기에 접근은 가능하다🙄</span><span>
</span></code></pre></section></pre>
<br/>
<h3 class="typography-h4  css-1f3zz6o" id="-호이스팅-hoisting-현상">3. 호이스팅 (Hoisting) 현상</h3>
<br/>
<style data-emotion="css 1f46fsl">.css-1f46fsl{position:relative;padding:11px 8px 12px 28px;background-color:var(--color-background-element);}</style><article class="css-1f46fsl"><style data-emotion="css 1c2gy26">.css-1c2gy26{position:absolute;top:12px;left:8px;}</style><style data-emotion="css oig4aq">.css-oig4aq{line-height:1.6;letter-spacing:0.00938em;font-size:16px;position:absolute;top:12px;left:8px;}.css-oig4aq[class^="typography-h"],.css-oig4aq[class^="typography-subtitle"]{font-weight:600;}.css-oig4aq[class^="typography-body"]{font-weight:400;}@media (min-width: 1080px){.css-oig4aq{font-size:18px;}}</style><span class="typography-body1 css-oig4aq">💡</span><p class="typography-body2  css-1dhx26">자바스크립트는 런타임 환경에서 코드를 한 줄 한 줄 읽어내려가는 인터프리터 언어이다.</p></article>
<br/>
<p>자바스트립트를 공부하면 제일 처음 배우게 되는 자바스크립트의 특징입니다. <del>(근데 이제 공부할 수록 가장 큰 혼란을 주는)</del>
위의 자바스크립트의 특징을 잘 기억해둔 후 아래 코드를 살펴봅시다.</p>
<br/>
<pre><section><header class="css-19ewdi0"><span class="typography-body1  css-1fte3e1">javascript</span></header><pre class="css-4iulct" style="text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;color:#eee;background:#2f2f2f;font-family:Roboto Mono, monospace;font-size:1em;line-height:1.5em;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;overflow:auto;position:relative;margin:0.5em 0;padding:1.25em 1em"><code class="language-javascript" style="text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;color:#eee;background:#2f2f2f;font-family:Roboto Mono, monospace;font-size:1em;line-height:1.5em;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none"><span class="token token console" style="color:#f2ff00">console</span><span class="token token" style="color:#89ddff">.</span><span class="token token method property-access" style="color:#c792ea">log</span><span class="token token" style="color:#89ddff">(</span><span>password</span><span class="token token" style="color:#89ddff">)</span><span class="token token" style="color:#89ddff">;</span><span> </span><span class="token token" style="color:#616161">//undefined</span><span>
</span>
<span></span><span class="token token" style="color:#c792ea">var</span><span> password </span><span class="token token" style="color:#89ddff">=</span><span> </span><span class="token token" style="color:#fd9170">123456</span><span class="token token" style="color:#89ddff">;</span><span>
</span></code></pre></section></pre>
<br/>
<p>위 코드는 에러가 나야할 것 같지만 undefined가 출력될 뿐 에러 없이 코드가 돌아갑니다. (<del>어째서..</del> 🤦)</p>
<br/>
<p>이는 “끌어올리다”라는 뜻을 가진 <style data-emotion="css 365ji8">.css-365ji8{color:#4FA299;font-weight:700;border-radius:4px;padding:4px;font-size:0.8em;background-color:var(--color-background-element);}</style><span class="css-365ji8">호이스팅</span>으로 인해 나타나는 현상으로 자바스크립트 엔진이 코드를 실행 하기 전에 <strong>코드의 변수, 함수, 클래스의 선언부를 스코프의 최상단으로 끌어올리는 것처럼 동작하는 현상</strong>을 말합니다.
(함수 선언문 위에서 함수 실행이 가능한 이유도 호이스팅 때문이죠.)</p>
<br/>
<p>var의 경우 호이스팅 시 <strong>선언과 동시에 undefined로 초기화</strong>되기 때문에 변수 선언문 이전에 변수를 참조해도 에러 없이 undefined 값을 얻을 수 있게 됩니다.</p>
<br/>
<h4 class="typography-subtitle1  css-1gs3x7d" id="var의-호이스팅">var의 호이스팅</h4>
<br/>
<p><img src="https://drive.google.com/uc?export=view&amp;id=1Fp1-ZFQeIhvim7xyAgEHu-O6iagpDqjA" alt="var의 호이스팅"/></p>
<br/>
<blockquote>
<ol>
<li>초기화 된 undefined 출력 😱</li>
<li>선언 후 값을 할당하지 않았으므로 undefined로 초기화</li>
<li>undefined 출력</li>
<li>123456 할당</li>
<li>123456 출력</li>
</ol>
</blockquote>
<br/>
<p>그럼 const와 let은 어떨까요?</p>
<br/>
<article class="css-1f46fsl"><span class="typography-body1 css-oig4aq">🚨</span><p class="typography-body2  css-1dhx26"><style data-emotion="css s9razd">.css-s9razd{color:red;font-weight:400;}</style><span class="css-s9razd">ReferenceError: Cannot access &#x27;userName&#x27; before initialization</span></p></article>
<br/>
<p>‘userName’이 초기화되기 전에 접근할 수 없다는 참조 에러가 뜨게 됩니다.
해당 코드 라인이 실행되는 시점에서 선언하지 않는 변수에 접근할 수 없는 게 우리가 예측할 수 있는 동작이므로 안심이 됩니다.
그런데 한 가지 의문인 점은 왜 ReferenceError: userName is not defined가 아닌 걸까요?
그 이유는 const와 let 또한 호이스팅 현상이 발생하기 때문입니다. 다만 var와의 차이점은 <strong>const와 let은 호이스팅과 동시에 변수가 초기화 되지 않는다는 것</strong>입니다.
<span class="css-365ji8">TDZ(Temporal Dead Zone)</span>, 일시적 사각지대라고 하여 <strong>변수 선언이 인식된 후 변수가 초기화 되기 전까지의 구간에서 const와 let 키워드로 선언한 변수에 접근하면 참조 에러가 발생</strong>하게 됩니다.</p>
<p>const와 let으로 선언한 변수는 자바스크립트 엔진이 변수 선언문에 도달했을 때 초기화되고 접근이 가능해집니다. 이때 <strong>const는 재할당이 불가능하기 때문에 초기화와 동시에 값이 할당</strong>되어야 합니다. let은 할당 값이 없다면 undefined로 초기화됩니다.</p>
<br/>
<h4 class="typography-subtitle1  css-1gs3x7d" id="const의-호이스팅">const의 호이스팅</h4>
<br/>
<p><img src="https://drive.google.com/uc?export=view&amp;id=1e6ONONIaXB_0jj3nXJUnFdZbrImqp5EH" alt="const의 호이스팅"/></p>
<br/>
<blockquote>
<ol>
<li>변수 선언이 끌어올려진 후 초기화 되지 않아 접근할 수 없음 <br/>(ReferenceError: Cannot access &#x27;password&#x27; before initialization)</li>
<li>값을 재할당 할 수 없는 상수(constant)이기에 초기화와 동시에 할당</li>
<li>할당된 값 123456 출력</li>
</ol>
</blockquote>
<br/>
<h4 class="typography-subtitle1  css-1gs3x7d" id="let의-호이스팅">let의 호이스팅</h4>
<br/>
<p><img src="https://drive.google.com/uc?export=view&amp;id=1IwziOv60kqGAzwjJjoAO8oqOFbVeNE-v" alt="let의 호이스팅"/></p>
<br/>
<blockquote>
<ol>
<li>변수 선언이 끌어올려진 후 초기화 되지 않아 접근할 수 없음 <br/>(ReferenceError: Cannot access &#x27;password&#x27; before initialization)</li>
<li>선언 후 값을 할당하지 않으면 undefined로 초기화</li>
<li>초기화 된 undefined 출력</li>
<li>값 123456 할당</li>
<li>할당된 123456 출력</li>
</ol>
</blockquote>
<br/>
<h2 class="typography-h3  css-f925jc" id="var를-지양해야-하는-이유">var를 지양해야 하는 이유</h2>
<br/>
<ul>
<li>재선언이 가능해 기존 선언을 덮어 쓸 수 있는 위험이 있습니다.</li>
<li>호이스팅으로 인하여 변수 선언문 이전에 변수에 접근 가능한 예기치 못한 동작이 발생합니다.</li>
<li>함수 스코프이기 때문에 if문, for문 등 문에서 쓰인 변수가 전역 변수가 되어 코드 여기 저기서 접근이 가능하고 변수 간 충돌이 발생할 수 위험이 있습니다.</li>
</ul>
<br/>
<p>=&gt; 따라서 코드의 예측 가능성과 안정성을 저하시키는 var를 지양하고 이를 보완하기 위해 나온 const와 let을 사용하는 것을 적극 권장합니다👍</p>
<br/>
<h2 class="typography-h3  css-f925jc" id="포스팅을-마치며">포스팅을 마치며</h2>
<br/>
<p>이렇게 var의 특징과 그 특징으로부터 발생하는 위험성에 대해 알아보았습니다. var를 사용하면 코드가 일단 돌아는가지만 왜 돌아가는지 혼란스럽고, 왜 여기서 내가 예상한 동작과 다른 버그가 발생하는지 파악하는 데 시간을 허비하게 될 가능성이 크겠죠. 그렇기 때문에 요즘에는 var를 사용하지 않는 추세입니다. 다만 사용하지 않으니 알아두지 않는 것이 아니라 어떤 특징을 가지고 있었는지, 그 특징으로부터 어떤 불편함이 발생했는지, 불편을 해소하기 위해 어떻게 해야 하는지 알아두는 것이 중요하다고 생각합니다. 그리고 ES6가 나온 이후에 개발을 시작한 것이 얼마나 큰 행복인지도요🥹</p></div></article><style data-emotion="css r0nx3b">.css-r0nx3b{margin-top:48px;font-size:14px;color:var( --color-tertiary);text-align:center;}.css-r0nx3b a{-webkit-text-decoration:underline;text-decoration:underline;}@media (min-width: 1080px){.css-r0nx3b{margin-top:120px;}}</style><p class="css-r0nx3b">게시글의 오류 지적, 내용 보충, 질문 등의 피드백은 언제나 환영입니다.<br/>아래 댓글창 혹은<!-- --> <a href="mailto:ysisys0202@gmail.com">ysisys0202@gmail.com</a>으로 남겨주세요.</p><style data-emotion="css 1qrcejr">.css-1qrcejr{margin-top:80px;}</style><div id="post-comments-wrapper" class="css-1qrcejr"></div></div></main><style data-emotion="css kmicch">.css-kmicch{position:relative;z-index:1;margin-top:-1px;padding:40px 16px;border-top:1px solid var( --color-tertiary);background-color:var(--color-background-global);}</style><footer class="css-kmicch"><ul><style data-emotion="css 1sy8r3">.css-1sy8r3 a{-webkit-text-decoration:underline;text-decoration:underline;}</style><li class="css-1sy8r3"><p class="typography-body2  css-1dhx26">연락처 :<a href="mailto:ysisys0202@gmail.com"> ysisys0202@gmail.com</a></p></li><li class="css-1sy8r3"><p class="typography-body2  css-1dhx26">아이콘 출처 :<a href="https://www.flaticon.com/free-icons/manual-book" title="manual book icons"> Manual book icons created by Kreev Studio - Flaticon</a></p></li></ul></footer></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"postData":{"categoryId":"1","categoryName":"Javascript","slug":"var는-왜-더이상-사용되지-않을까","content":"\u003cp\u003e{intro}\u003c/p\u003e\n\u003cSpacing size=\"lg\" /\u003e\n\n## 프로그래밍에서 변수란?\n\u003cbr/\u003e\n프로그래밍에서 변수란 **하나의 값을 저장하기 위해 이름이 붙은 메모리 공간**을 뜻합니다.\n\u003cbr/\u003e\n```javascript \nvar password = 123456; \n```\n\u003cbr/\u003e\n위와 같이 변수를 선언하고 값을 할당하면 3단계에 걸쳐 변수에 값이 저장됩니다.\n\u003cbr/\u003e\n\u003cPostImage src=\"https://drive.google.com/uc?export=view\u0026id=1WtfApWevV7lzHhaKIx6mF-KktJy5wZBo\" alt=\"변수 선언 과정\" width=\"580\" height=\"392\"/\u003e\n\u003cbr/\u003e\n\u003e 1. 선언 : 자바스크립트 엔진이 **변수의 식별자를 인식하는 단계**입니다. 식별자만 인식할 뿐 값이 저장되지는 않습니다.\n\u003e 2. 초기화 : 변수 식별자가 인식된 후, **메모리 공간을 확보하고 초기값을 설정하는 단계**입니다. 이 때 식별자는 확보된 메모리 공간의 주소값을 가르킵니다. 초기 값이 명시되어 있지 않은 경우 undefined로 초기화 됩니다.\n\u003e 3. 할당 : 식별자가 가르키고 있는 주소의 **메모리 공간에 값을 저장하는 단계**입니다.\n\u003cbr/\u003e\n## var와 const, let의 차이\n\u003cbr/\u003e\n이제 자바스크립트에서 변수를 선언할 때 사용하는 세가지 키워드 var와 const,let의 차이점에 대해 알아봅시다.\n\u003cbr/\u003e\n### 1. 재선언 , 재할당 가능 여부\n\u003cbr/\u003e\n#### 재선언과 재할당이란?\n\u003cbr/\u003e\n**재선언** : 이미 선언된 변수 식별자를 다시 사용하여 변수를 선언하는 것을 의미합니다.\n\u003cbr/\u003e\n```javascript \nvar password = 123456; \nvar password = 654321; // 이미 사용된 password 식별자를 사용하여 변수를 재선언\n\nconsole.log(654321); // 재선언 시 할당된 654321이 출력된다.\n```\n\u003cbr/\u003e\n**재할당** : 변수에 값을 다시 할당하는 것을 의미합니다.\n\u003cbr/\u003e\n```javascript \nvar password = 123456; \npassword = 654321; // password 값에 값을 재할당\n\nconsole.log(654321); // 재할당 된 654321 값이 출력된다.\n```\n\u003cbr/\u003e\nvar와 const, let의 재선언, 재할당 여부는 아래와 같습니다.\n\u003cbr/\u003e\n| 변수 선언 키워드| 재선언 | 재할당 |\n| ----------- | ------ | ------ |\n| var         | O      | O      |\n| const (ES6) | X      | X      |\n| let (ES6)   | X      | O      |\n\u003cbr/\u003e\n1. **var** : 재선언과 재할당 **모두 가능**합니다.\n2. **const** : 재선언과 재할당 **모두 불가능**합니다. 값이 변하지 않으니, 선언과 동시에 값이 할당되어야 합니다. 재할당이 허용되지 않으므로 상수(constance)라고도 합니다.\n3. **let** : **재할당만 가능**하고 재선언은 허용되지 않습니다.\n\u003cbr/\u003e\n\u003cPostImage src=\"https://drive.google.com/uc?export=view\u0026id=14fhjKXNkr4VFS8JnRq4UDa8c052BeEp9\" alt=\"챗지피티한테 let의 의미를 물어보았다.\" width=\"558\" height=\"266\" caption=\"그래서 let이 무슨 뜻이냐고요...\"/\u003e\n\u003cbr/\u003e\n#### 재선언의 위험성 🚨\n\u003cbr/\u003e\n```javascript \nvar password = 123456; \n\n// 1000 lines later ...🐌\n\nvar password = 654321; \n// 코드가 너무 길어져 실수로 위에 선언된 password를 덮어쓴다면?!😱\n```\n\u003cbr/\u003e\n위와 같이 코드가 길어지거나 다른 개발자와 협업하여 일하는 경우 기존에 변수가 재선언되어 덮어써진다면 생각지 못한 에러가 발생하겠죠? 이런 상황을 미연에 방지하기 위해 **재선언을 허용하지 않는 키워드인 const와 let을 사용하는 것이 좋습니다.**\n\u003cbr/\u003e\n#### 어떤 상황에서 const를 쓰고 let을 써야할까요?🤔\n\u003cbr/\u003e\n **변수에 값을 재할당해야 할 이유가 없는 모든 경우에 const를 쓰는 것이 바람직합니다.** const는 재할당조차 허용하지 않는 가장 엄격한 키워드이기 때문에 의도치 않게 값을 변경시키는 일이 발생하지 않기 때문입니다.\n\u003cbr/\u003e\n```javascript\nconst password = 123456; \n\npassword = 654321; \n// TypeError: Assignment to constant variable\n```\n\u003cbr/\u003e\n 부득이하게 값이 재할당 되어야 할 때는 let을 사용하면 됩니다. 저는 주로 if문, switch문 같은 조건문에서 조건에 따라 값을 다르게 할당해야하는 경우에 사용했습니다. \n (~~만약문이라고 쓰고 5초간 뭐가 이상한지 몰랐던 사람이 바로 저예요~~)\n\u003cbr/\u003e\n### 2. 스코프 (scope)\n\u003cbr/\u003e\n#### 스코프란?\n\u003cbr/\u003e\n스코프(scope)는 **변수에 접근할 수 있는 유효 범위**를 뜻합니다.\u003cbr/\u003e\n\u003cbr/\u003e\n**전역 스코프 (Global Scope)** : 함수나 블럭 바깥의 최상위 공간입니다. 전역 스코프에 선언된 변수는 어디서나 접근 가능하며 이를 전역 변수라고 합니다.\n**지역 스코프 (Local Scope)** : 함수나 블럭 내부를 뜻합니다. 지역 스코프에 선언된 변수는 해당 스코프 내에서만 접근 가능하여 이를 지역 변수라고 합니다.\n\u003cbr/\u003e\n\u003cPostImage src=\"https://drive.google.com/uc?export=view\u0026id=1ZAsj37PaM6f7rCxrv65DjyHeVz4BMqy_\" alt=\"스코프\" width=\"558\" height=\"266\"/\u003e\n\u003cbr/\u003e\n\u003e1. 전역 스코프에 선언된 변수는 어디서나 접근 가능합니다.\n\u003e2. 지역 스코프에 선언된 변수는 전역 스코프에서 접근할 수 없습니다.\n  \u003cbr/\u003e (전역 스코프에서 outerFunction에 선언된 outerVar에 접근할 수 없음)\n\u003e3. 함수가 중첩된 경우 하위 함수에서는 상위 함수에 선언된 변수에 접근할 수 있지만 외부 함수에서 내부 함수에 선언된 변수에 접근할 수 없습니다.\n  \u003cbr/\u003e (outerFunction에서 innerFunction에 선언된 innerVar에 접근할 수 없음)\n\u003e4. 변수에 접근할 때 함수 내부에 선언되지 않았다면 상위 스코프로 올라가서 찾습니다. (스코프 체인)\n  \u003cbr/\u003e (innerFunction은 outerFunction, 전역 스코프에 있는 변수에 모두 접근이 가능)\n\n\u003cbr/\u003e\n#### var와 const, let의 스코프 차이\n\u003cbr/\u003e\n- **var의 스코프** : **함수 레벨** (function level)\n- **const, let의 스코프** : **블럭 레벨** (block level)\n\u003cbr/\u003e\n#### 함수 스코프의 단점\n\u003cbr/\u003e\n함수 선언 시에 블럭이 사용되니 둘이 비슷한 것이 아닌가? 라는 생각이 들수도 있지만 함수 레벨의 유효 범위에서는 if문, for문처럼 함수가 아닌 문(statement) 안에서 선언한 변수가 전역변수가 되어 코드 여기저기서 참조할 수 있게 될뿐더러 다른 변수와 충돌할 가능성이 있습니다. 때문에 **안정적이고 예측 가능한 변수 사용을 위해 블록 스코프인 const와 let을 사용하는 것이 좋습니다.**\n\u003cbr/\u003e\n```javascript\nfor (var i = 0; i \u003c 10; i++) {\n  var a = \"a\";\n}\nconsole.log(i); // 10 =\u003e 루프 헤더에 선언된 i에 접근 가능\nconsole.log(a); // 'a' =\u003e for문 안에 선언된 a에도 접근 가능\n\nif (false) {\n  var b = \"b\";\n}\n\nconsole.log(b); \n// undefined =\u003e if문의 조건이 거짓이므로 값을 할당되지 않았지만 전역변수이기에 접근은 가능하다🙄\n``` \n\u003cbr/\u003e\n### 3. 호이스팅 (Hoisting) 현상\n\u003cbr/\u003e\n\u003cCallout\u003e\n자바스크립트는 런타임 환경에서 코드를 한 줄 한 줄 읽어내려가는 인터프리터 언어이다.\n\u003c/Callout\u003e\n\u003cbr/\u003e\n자바스트립트를 공부하면 제일 처음 배우게 되는 자바스크립트의 특징입니다. ~~(근데 이제 공부할 수록 가장 큰 혼란을 주는)~~\n위의 자바스크립트의 특징을 잘 기억해둔 후 아래 코드를 살펴봅시다.\n\u003cbr/\u003e\n```javascript\nconsole.log(password); //undefined\n\nvar password = 123456;\n```\n\u003cbr/\u003e\n위 코드는 에러가 나야할 것 같지만 undefined가 출력될 뿐 에러 없이 코드가 돌아갑니다. (~~어째서..~~ 🤦)\n\u003cbr/\u003e\n이는 “끌어올리다”라는 뜻을 가진 \u003cHighlightText type=\"background\" fontWeight={700}\u003e호이스팅\u003c/HighlightText\u003e으로 인해 나타나는 현상으로 자바스크립트 엔진이 코드를 실행 하기 전에 **코드의 변수, 함수, 클래스의 선언부를 스코프의 최상단으로 끌어올리는 것처럼 동작하는 현상**을 말합니다. \n(함수 선언문 위에서 함수 실행이 가능한 이유도 호이스팅 때문이죠.)\n\u003cbr/\u003e\nvar의 경우 호이스팅 시 **선언과 동시에 undefined로 초기화**되기 때문에 변수 선언문 이전에 변수를 참조해도 에러 없이 undefined 값을 얻을 수 있게 됩니다.\n\u003cbr/\u003e\n#### var의 호이스팅\n\u003cbr/\u003e\n![var의 호이스팅](https://drive.google.com/uc?export=view\u0026id=1Fp1-ZFQeIhvim7xyAgEHu-O6iagpDqjA)\n\u003cbr/\u003e\n\u003e 1. 초기화 된 undefined 출력 😱\n\u003e 2. 선언 후 값을 할당하지 않았으므로 undefined로 초기화\n\u003e 3. undefined 출력\n\u003e 4. 123456 할당\n\u003e 5. 123456 출력\n\n\u003cbr/\u003e\n그럼 const와 let은 어떨까요?\n\u003cbr/\u003e\n\u003cCallout icon=\"🚨\"\u003e\n  \u003cHighlightText textColor=\"red\"\u003eReferenceError: Cannot access 'userName' before initialization\u003c/HighlightText \u003e\n\u003c/Callout\u003e\n\u003cbr/\u003e\n‘userName’이 초기화되기 전에 접근할 수 없다는 참조 에러가 뜨게 됩니다. \n해당 코드 라인이 실행되는 시점에서 선언하지 않는 변수에 접근할 수 없는 게 우리가 예측할 수 있는 동작이므로 안심이 됩니다.\n그런데 한 가지 의문인 점은 왜 ReferenceError: userName is not defined가 아닌 걸까요?\n그 이유는 const와 let 또한 호이스팅 현상이 발생하기 때문입니다. 다만 var와의 차이점은 **const와 let은 호이스팅과 동시에 변수가 초기화 되지 않는다는 것**입니다. \n\u003cHighlightText type=\"background\" fontWeight={700}\u003eTDZ(Temporal Dead Zone)\u003c/HighlightText\u003e, 일시적 사각지대라고 하여 **변수 선언이 인식된 후 변수가 초기화 되기 전까지의 구간에서 const와 let 키워드로 선언한 변수에 접근하면 참조 에러가 발생**하게 됩니다.\n\nconst와 let으로 선언한 변수는 자바스크립트 엔진이 변수 선언문에 도달했을 때 초기화되고 접근이 가능해집니다. 이때 **const는 재할당이 불가능하기 때문에 초기화와 동시에 값이 할당**되어야 합니다. let은 할당 값이 없다면 undefined로 초기화됩니다.\n\u003cbr/\u003e\n#### const의 호이스팅\n\u003cbr/\u003e\n![const의 호이스팅](https://drive.google.com/uc?export=view\u0026id=1e6ONONIaXB_0jj3nXJUnFdZbrImqp5EH)\n\u003cbr/\u003e\n\u003e 1. 변수 선언이 끌어올려진 후 초기화 되지 않아 접근할 수 없음 \u003cbr/\u003e(ReferenceError: Cannot access 'password' before initialization)\n\u003e 2. 값을 재할당 할 수 없는 상수(constant)이기에 초기화와 동시에 할당\n\u003e 3. 할당된 값 123456 출력\n\n\u003cbr/\u003e\n#### let의 호이스팅\n\u003cbr/\u003e\n![let의 호이스팅](https://drive.google.com/uc?export=view\u0026id=1IwziOv60kqGAzwjJjoAO8oqOFbVeNE-v)\n\u003cbr/\u003e\n\u003e 1. 변수 선언이 끌어올려진 후 초기화 되지 않아 접근할 수 없음 \u003cbr/\u003e(ReferenceError: Cannot access 'password' before initialization)\n\u003e 2. 선언 후 값을 할당하지 않으면 undefined로 초기화 \n\u003e 3. 초기화 된 undefined 출력\n\u003e 4. 값 123456 할당\n\u003e 5. 할당된 123456 출력\n\n\u003cbr/\u003e\n## var를 지양해야 하는 이유\n\u003cbr/\u003e\n - 재선언이 가능해 기존 선언을 덮어 쓸 수 있는 위험이 있습니다.\n - 호이스팅으로 인하여 변수 선언문 이전에 변수에 접근 가능한 예기치 못한 동작이 발생합니다.\n - 함수 스코프이기 때문에 if문, for문 등 문에서 쓰인 변수가 전역 변수가 되어 코드 여기 저기서 접근이 가능하고 변수 간 충돌이 발생할 수 위험이 있습니다.\n\u003cbr/\u003e\n=\u003e 따라서 코드의 예측 가능성과 안정성을 저하시키는 var를 지양하고 이를 보완하기 위해 나온 const와 let을 사용하는 것을 적극 권장합니다👍\n\u003cbr/\u003e\n## 포스팅을 마치며\n\u003cbr/\u003e\n이렇게 var의 특징과 그 특징으로부터 발생하는 위험성에 대해 알아보았습니다. var를 사용하면 코드가 일단 돌아는가지만 왜 돌아가는지 혼란스럽고, 왜 여기서 내가 예상한 동작과 다른 버그가 발생하는지 파악하는 데 시간을 허비하게 될 가능성이 크겠죠. 그렇기 때문에 요즘에는 var를 사용하지 않는 추세입니다. 다만 사용하지 않으니 알아두지 않는 것이 아니라 어떤 특징을 가지고 있었는지, 그 특징으로부터 어떤 불편함이 발생했는지, 불편을 해소하기 위해 어떻게 해야 하는지 알아두는 것이 중요하다고 생각합니다. 그리고 ES6가 나온 이후에 개발을 시작한 것이 얼마나 큰 행복인지도요🥹\n\n\n\n\n\n\n\n\n","title":"var는 왜 더이상 사용되지 않을까","subTitle":"var와 const, let의 차이점 알아보기","intro":"혹시 자바스크립트에서 var 사용을 지양하라는 말을 들어보셨나요? \n var는 한때 자바스크립트에서 변수를 선언할 수 있는 유일한 키워드였습니다. 하지만 ES6부터 모던 자바스크립트를 사용하는 개발자들은 더 이상 var를 사용하지 않고 있습니다. ES6부터 포함된 const와 let이라는 변수 선언 키워드가 있기 때문입니다. 하지만 var를 사용하지 않는 이유가 그저 오래된 문법이라서일까요? var와 const, let의 차이점을 알아보며 var가 외면받는 이유에 대해 알아보겠습니다.","isFeatured":true,"createdAt":"2024-07-24","thumbnail":"https://drive.google.com/uc?export=view\u0026id=1KhO3x8PP7eh40G3ux4RsEg40L32eVkuC","keywords":"자바스크립트, javascript, 변수, variables, var, const, let, hoisting, 호이스팅, scope"},"mdx":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    h2: \"h2\",\n    p: \"p\",\n    strong: \"strong\",\n    pre: \"pre\",\n    code: \"code\",\n    blockquote: \"blockquote\",\n    ol: \"ol\",\n    li: \"li\",\n    h3: \"h3\",\n    h4: \"h4\",\n    table: \"table\",\n    thead: \"thead\",\n    tr: \"tr\",\n    th: \"th\",\n    tbody: \"tbody\",\n    td: \"td\",\n    del: \"del\",\n    ul: \"ul\",\n    img: \"img\"\n  }, _provideComponents(), props.components), {Spacing, PostImage, Callout, HighlightText} = _components;\n  if (!Callout) _missingMdxReference(\"Callout\", true);\n  if (!HighlightText) _missingMdxReference(\"HighlightText\", true);\n  if (!PostImage) _missingMdxReference(\"PostImage\", true);\n  if (!Spacing) _missingMdxReference(\"Spacing\", true);\n  return _jsxs(_Fragment, {\n    children: [_jsx(\"p\", {\n      children: intro\n    }), \"\\n\", _jsx(Spacing, {\n      size: \"lg\"\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"프로그래밍에서 변수란?\"\n    }), \"\\n\", _jsx(\"br\", {}), \"\\n\", _jsxs(_components.p, {\n      children: [\"프로그래밍에서 변수란 \", _jsx(_components.strong, {\n        children: \"하나의 값을 저장하기 위해 이름이 붙은 메모리 공간\"\n      }), \"을 뜻합니다.\"]\n    }), \"\\n\", _jsx(\"br\", {}), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-javascript\",\n        children: \"var password = 123456; \\n\"\n      })\n    }), \"\\n\", _jsx(\"br\", {}), \"\\n\", _jsx(_components.p, {\n      children: \"위와 같이 변수를 선언하고 값을 할당하면 3단계에 걸쳐 변수에 값이 저장됩니다.\"\n    }), \"\\n\", _jsx(\"br\", {}), \"\\n\", _jsx(PostImage, {\n      src: \"https://drive.google.com/uc?export=view\u0026id=1WtfApWevV7lzHhaKIx6mF-KktJy5wZBo\",\n      alt: \"변수 선언 과정\",\n      width: \"580\",\n      height: \"392\"\n    }), \"\\n\", _jsx(\"br\", {}), \"\\n\", _jsxs(_components.blockquote, {\n      children: [\"\\n\", _jsxs(_components.ol, {\n        children: [\"\\n\", _jsxs(_components.li, {\n          children: [\"선언 : 자바스크립트 엔진이 \", _jsx(_components.strong, {\n            children: \"변수의 식별자를 인식하는 단계\"\n          }), \"입니다. 식별자만 인식할 뿐 값이 저장되지는 않습니다.\"]\n        }), \"\\n\", _jsxs(_components.li, {\n          children: [\"초기화 : 변수 식별자가 인식된 후, \", _jsx(_components.strong, {\n            children: \"메모리 공간을 확보하고 초기값을 설정하는 단계\"\n          }), \"입니다. 이 때 식별자는 확보된 메모리 공간의 주소값을 가르킵니다. 초기 값이 명시되어 있지 않은 경우 undefined로 초기화 됩니다.\"]\n        }), \"\\n\", _jsxs(_components.li, {\n          children: [\"할당 : 식별자가 가르키고 있는 주소의 \", _jsx(_components.strong, {\n            children: \"메모리 공간에 값을 저장하는 단계\"\n          }), \"입니다.\"]\n        }), \"\\n\"]\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(\"br\", {}), \"\\n\", _jsx(_components.h2, {\n      children: \"var와 const, let의 차이\"\n    }), \"\\n\", _jsx(\"br\", {}), \"\\n\", _jsx(_components.p, {\n      children: \"이제 자바스크립트에서 변수를 선언할 때 사용하는 세가지 키워드 var와 const,let의 차이점에 대해 알아봅시다.\"\n    }), \"\\n\", _jsx(\"br\", {}), \"\\n\", _jsx(_components.h3, {\n      children: \"1. 재선언 , 재할당 가능 여부\"\n    }), \"\\n\", _jsx(\"br\", {}), \"\\n\", _jsx(_components.h4, {\n      children: \"재선언과 재할당이란?\"\n    }), \"\\n\", _jsx(\"br\", {}), \"\\n\", _jsxs(_components.p, {\n      children: [_jsx(_components.strong, {\n        children: \"재선언\"\n      }), \" : 이미 선언된 변수 식별자를 다시 사용하여 변수를 선언하는 것을 의미합니다.\"]\n    }), \"\\n\", _jsx(\"br\", {}), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-javascript\",\n        children: \"var password = 123456; \\nvar password = 654321; // 이미 사용된 password 식별자를 사용하여 변수를 재선언\\n\\nconsole.log(654321); // 재선언 시 할당된 654321이 출력된다.\\n\"\n      })\n    }), \"\\n\", _jsx(\"br\", {}), \"\\n\", _jsxs(_components.p, {\n      children: [_jsx(_components.strong, {\n        children: \"재할당\"\n      }), \" : 변수에 값을 다시 할당하는 것을 의미합니다.\"]\n    }), \"\\n\", _jsx(\"br\", {}), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-javascript\",\n        children: \"var password = 123456; \\npassword = 654321; // password 값에 값을 재할당\\n\\nconsole.log(654321); // 재할당 된 654321 값이 출력된다.\\n\"\n      })\n    }), \"\\n\", _jsx(\"br\", {}), \"\\n\", _jsx(_components.p, {\n      children: \"var와 const, let의 재선언, 재할당 여부는 아래와 같습니다.\"\n    }), \"\\n\", _jsx(\"br\", {}), \"\\n\", _jsxs(_components.table, {\n      children: [_jsx(_components.thead, {\n        children: _jsxs(_components.tr, {\n          children: [_jsx(_components.th, {\n            children: \"변수 선언 키워드\"\n          }), _jsx(_components.th, {\n            children: \"재선언\"\n          }), _jsx(_components.th, {\n            children: \"재할당\"\n          })]\n        })\n      }), _jsxs(_components.tbody, {\n        children: [_jsxs(_components.tr, {\n          children: [_jsx(_components.td, {\n            children: \"var\"\n          }), _jsx(_components.td, {\n            children: \"O\"\n          }), _jsx(_components.td, {\n            children: \"O\"\n          })]\n        }), _jsxs(_components.tr, {\n          children: [_jsx(_components.td, {\n            children: \"const (ES6)\"\n          }), _jsx(_components.td, {\n            children: \"X\"\n          }), _jsx(_components.td, {\n            children: \"X\"\n          })]\n        }), _jsxs(_components.tr, {\n          children: [_jsx(_components.td, {\n            children: \"let (ES6)\"\n          }), _jsx(_components.td, {\n            children: \"X\"\n          }), _jsx(_components.td, {\n            children: \"O\"\n          })]\n        })]\n      })]\n    }), \"\\n\", _jsx(\"br\", {}), \"\\n\", _jsxs(_components.ol, {\n      children: [\"\\n\", _jsxs(_components.li, {\n        children: [_jsx(_components.strong, {\n          children: \"var\"\n        }), \" : 재선언과 재할당 \", _jsx(_components.strong, {\n          children: \"모두 가능\"\n        }), \"합니다.\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [_jsx(_components.strong, {\n          children: \"const\"\n        }), \" : 재선언과 재할당 \", _jsx(_components.strong, {\n          children: \"모두 불가능\"\n        }), \"합니다. 값이 변하지 않으니, 선언과 동시에 값이 할당되어야 합니다. 재할당이 허용되지 않으므로 상수(constance)라고도 합니다.\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [_jsx(_components.strong, {\n          children: \"let\"\n        }), \" : \", _jsx(_components.strong, {\n          children: \"재할당만 가능\"\n        }), \"하고 재선언은 허용되지 않습니다.\"]\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(\"br\", {}), \"\\n\", _jsx(PostImage, {\n      src: \"https://drive.google.com/uc?export=view\u0026id=14fhjKXNkr4VFS8JnRq4UDa8c052BeEp9\",\n      alt: \"챗지피티한테 let의 의미를 물어보았다.\",\n      width: \"558\",\n      height: \"266\",\n      caption: \"그래서 let이 무슨 뜻이냐고요...\"\n    }), \"\\n\", _jsx(\"br\", {}), \"\\n\", _jsx(_components.h4, {\n      children: \"재선언의 위험성 🚨\"\n    }), \"\\n\", _jsx(\"br\", {}), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-javascript\",\n        children: \"var password = 123456; \\n\\n// 1000 lines later ...🐌\\n\\nvar password = 654321; \\n// 코드가 너무 길어져 실수로 위에 선언된 password를 덮어쓴다면?!😱\\n\"\n      })\n    }), \"\\n\", _jsx(\"br\", {}), \"\\n\", _jsxs(_components.p, {\n      children: [\"위와 같이 코드가 길어지거나 다른 개발자와 협업하여 일하는 경우 기존에 변수가 재선언되어 덮어써진다면 생각지 못한 에러가 발생하겠죠? 이런 상황을 미연에 방지하기 위해 \", _jsx(_components.strong, {\n        children: \"재선언을 허용하지 않는 키워드인 const와 let을 사용하는 것이 좋습니다.\"\n      })]\n    }), \"\\n\", _jsx(\"br\", {}), \"\\n\", _jsx(_components.h4, {\n      children: \"어떤 상황에서 const를 쓰고 let을 써야할까요?🤔\"\n    }), \"\\n\", _jsx(\"br\", {}), \"\\n\", _jsxs(_components.p, {\n      children: [_jsx(_components.strong, {\n        children: \"변수에 값을 재할당해야 할 이유가 없는 모든 경우에 const를 쓰는 것이 바람직합니다.\"\n      }), \" const는 재할당조차 허용하지 않는 가장 엄격한 키워드이기 때문에 의도치 않게 값을 변경시키는 일이 발생하지 않기 때문입니다.\"]\n    }), \"\\n\", _jsx(\"br\", {}), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-javascript\",\n        children: \"const password = 123456; \\n\\npassword = 654321; \\n// TypeError: Assignment to constant variable\\n\"\n      })\n    }), \"\\n\", _jsx(\"br\", {}), \"\\n\", _jsxs(_components.p, {\n      children: [\"부득이하게 값이 재할당 되어야 할 때는 let을 사용하면 됩니다. 저는 주로 if문, switch문 같은 조건문에서 조건에 따라 값을 다르게 할당해야하는 경우에 사용했습니다.\\n(\", _jsx(_components.del, {\n        children: \"만약문이라고 쓰고 5초간 뭐가 이상한지 몰랐던 사람이 바로 저예요\"\n      }), \")\"]\n    }), \"\\n\", _jsx(\"br\", {}), \"\\n\", _jsx(_components.h3, {\n      children: \"2. 스코프 (scope)\"\n    }), \"\\n\", _jsx(\"br\", {}), \"\\n\", _jsx(_components.h4, {\n      children: \"스코프란?\"\n    }), \"\\n\", _jsx(\"br\", {}), \"\\n\", _jsxs(_components.p, {\n      children: [\"스코프(scope)는 \", _jsx(_components.strong, {\n        children: \"변수에 접근할 수 있는 유효 범위\"\n      }), \"를 뜻합니다.\", _jsx(\"br\", {})]\n    }), \"\\n\", _jsx(\"br\", {}), \"\\n\", _jsxs(_components.p, {\n      children: [_jsx(_components.strong, {\n        children: \"전역 스코프 (Global Scope)\"\n      }), \" : 함수나 블럭 바깥의 최상위 공간입니다. 전역 스코프에 선언된 변수는 어디서나 접근 가능하며 이를 전역 변수라고 합니다.\\n\", _jsx(_components.strong, {\n        children: \"지역 스코프 (Local Scope)\"\n      }), \" : 함수나 블럭 내부를 뜻합니다. 지역 스코프에 선언된 변수는 해당 스코프 내에서만 접근 가능하여 이를 지역 변수라고 합니다.\"]\n    }), \"\\n\", _jsx(\"br\", {}), \"\\n\", _jsx(PostImage, {\n      src: \"https://drive.google.com/uc?export=view\u0026id=1ZAsj37PaM6f7rCxrv65DjyHeVz4BMqy_\",\n      alt: \"스코프\",\n      width: \"558\",\n      height: \"266\"\n    }), \"\\n\", _jsx(\"br\", {}), \"\\n\", _jsxs(_components.blockquote, {\n      children: [\"\\n\", _jsxs(_components.ol, {\n        children: [\"\\n\", _jsx(_components.li, {\n          children: \"전역 스코프에 선언된 변수는 어디서나 접근 가능합니다.\"\n        }), \"\\n\", _jsxs(_components.li, {\n          children: [\"지역 스코프에 선언된 변수는 전역 스코프에서 접근할 수 없습니다.\\n\", _jsx(\"br\", {}), \" (전역 스코프에서 outerFunction에 선언된 outerVar에 접근할 수 없음)\"]\n        }), \"\\n\", _jsxs(_components.li, {\n          children: [\"함수가 중첩된 경우 하위 함수에서는 상위 함수에 선언된 변수에 접근할 수 있지만 외부 함수에서 내부 함수에 선언된 변수에 접근할 수 없습니다.\\n\", _jsx(\"br\", {}), \" (outerFunction에서 innerFunction에 선언된 innerVar에 접근할 수 없음)\"]\n        }), \"\\n\", _jsxs(_components.li, {\n          children: [\"변수에 접근할 때 함수 내부에 선언되지 않았다면 상위 스코프로 올라가서 찾습니다. (스코프 체인)\\n\", _jsx(\"br\", {}), \" (innerFunction은 outerFunction, 전역 스코프에 있는 변수에 모두 접근이 가능)\"]\n        }), \"\\n\"]\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(\"br\", {}), \"\\n\", _jsx(_components.h4, {\n      children: \"var와 const, let의 스코프 차이\"\n    }), \"\\n\", _jsx(\"br\", {}), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsxs(_components.li, {\n        children: [_jsx(_components.strong, {\n          children: \"var의 스코프\"\n        }), \" : \", _jsx(_components.strong, {\n          children: \"함수 레벨\"\n        }), \" (function level)\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [_jsx(_components.strong, {\n          children: \"const, let의 스코프\"\n        }), \" : \", _jsx(_components.strong, {\n          children: \"블럭 레벨\"\n        }), \" (block level)\"]\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(\"br\", {}), \"\\n\", _jsx(_components.h4, {\n      children: \"함수 스코프의 단점\"\n    }), \"\\n\", _jsx(\"br\", {}), \"\\n\", _jsxs(_components.p, {\n      children: [\"함수 선언 시에 블럭이 사용되니 둘이 비슷한 것이 아닌가? 라는 생각이 들수도 있지만 함수 레벨의 유효 범위에서는 if문, for문처럼 함수가 아닌 문(statement) 안에서 선언한 변수가 전역변수가 되어 코드 여기저기서 참조할 수 있게 될뿐더러 다른 변수와 충돌할 가능성이 있습니다. 때문에 \", _jsx(_components.strong, {\n        children: \"안정적이고 예측 가능한 변수 사용을 위해 블록 스코프인 const와 let을 사용하는 것이 좋습니다.\"\n      })]\n    }), \"\\n\", _jsx(\"br\", {}), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-javascript\",\n        children: \"for (var i = 0; i \u003c 10; i++) {\\n  var a = \\\"a\\\";\\n}\\nconsole.log(i); // 10 =\u003e 루프 헤더에 선언된 i에 접근 가능\\nconsole.log(a); // 'a' =\u003e for문 안에 선언된 a에도 접근 가능\\n\\nif (false) {\\n  var b = \\\"b\\\";\\n}\\n\\nconsole.log(b); \\n// undefined =\u003e if문의 조건이 거짓이므로 값을 할당되지 않았지만 전역변수이기에 접근은 가능하다🙄\\n\"\n      })\n    }), \"\\n\", _jsx(\"br\", {}), \"\\n\", _jsx(_components.h3, {\n      children: \"3. 호이스팅 (Hoisting) 현상\"\n    }), \"\\n\", _jsx(\"br\", {}), \"\\n\", _jsx(Callout, {\n      children: _jsx(_components.p, {\n        children: \"자바스크립트는 런타임 환경에서 코드를 한 줄 한 줄 읽어내려가는 인터프리터 언어이다.\"\n      })\n    }), \"\\n\", _jsx(\"br\", {}), \"\\n\", _jsxs(_components.p, {\n      children: [\"자바스트립트를 공부하면 제일 처음 배우게 되는 자바스크립트의 특징입니다. \", _jsx(_components.del, {\n        children: \"(근데 이제 공부할 수록 가장 큰 혼란을 주는)\"\n      }), \"\\n위의 자바스크립트의 특징을 잘 기억해둔 후 아래 코드를 살펴봅시다.\"]\n    }), \"\\n\", _jsx(\"br\", {}), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-javascript\",\n        children: \"console.log(password); //undefined\\n\\nvar password = 123456;\\n\"\n      })\n    }), \"\\n\", _jsx(\"br\", {}), \"\\n\", _jsxs(_components.p, {\n      children: [\"위 코드는 에러가 나야할 것 같지만 undefined가 출력될 뿐 에러 없이 코드가 돌아갑니다. (\", _jsx(_components.del, {\n        children: \"어째서..\"\n      }), \" 🤦)\"]\n    }), \"\\n\", _jsx(\"br\", {}), \"\\n\", _jsxs(_components.p, {\n      children: [\"이는 “끌어올리다”라는 뜻을 가진 \", _jsx(HighlightText, {\n        type: \"background\",\n        fontWeight: 700,\n        children: \"호이스팅\"\n      }), \"으로 인해 나타나는 현상으로 자바스크립트 엔진이 코드를 실행 하기 전에 \", _jsx(_components.strong, {\n        children: \"코드의 변수, 함수, 클래스의 선언부를 스코프의 최상단으로 끌어올리는 것처럼 동작하는 현상\"\n      }), \"을 말합니다.\\n(함수 선언문 위에서 함수 실행이 가능한 이유도 호이스팅 때문이죠.)\"]\n    }), \"\\n\", _jsx(\"br\", {}), \"\\n\", _jsxs(_components.p, {\n      children: [\"var의 경우 호이스팅 시 \", _jsx(_components.strong, {\n        children: \"선언과 동시에 undefined로 초기화\"\n      }), \"되기 때문에 변수 선언문 이전에 변수를 참조해도 에러 없이 undefined 값을 얻을 수 있게 됩니다.\"]\n    }), \"\\n\", _jsx(\"br\", {}), \"\\n\", _jsx(_components.h4, {\n      children: \"var의 호이스팅\"\n    }), \"\\n\", _jsx(\"br\", {}), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"https://drive.google.com/uc?export=view\u0026id=1Fp1-ZFQeIhvim7xyAgEHu-O6iagpDqjA\",\n        alt: \"var의 호이스팅\"\n      })\n    }), \"\\n\", _jsx(\"br\", {}), \"\\n\", _jsxs(_components.blockquote, {\n      children: [\"\\n\", _jsxs(_components.ol, {\n        children: [\"\\n\", _jsx(_components.li, {\n          children: \"초기화 된 undefined 출력 😱\"\n        }), \"\\n\", _jsx(_components.li, {\n          children: \"선언 후 값을 할당하지 않았으므로 undefined로 초기화\"\n        }), \"\\n\", _jsx(_components.li, {\n          children: \"undefined 출력\"\n        }), \"\\n\", _jsx(_components.li, {\n          children: \"123456 할당\"\n        }), \"\\n\", _jsx(_components.li, {\n          children: \"123456 출력\"\n        }), \"\\n\"]\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(\"br\", {}), \"\\n\", _jsx(_components.p, {\n      children: \"그럼 const와 let은 어떨까요?\"\n    }), \"\\n\", _jsx(\"br\", {}), \"\\n\", _jsx(Callout, {\n      icon: \"🚨\",\n      children: _jsx(HighlightText, {\n        textColor: \"red\",\n        children: \"ReferenceError: Cannot access 'userName' before initialization\"\n      })\n    }), \"\\n\", _jsx(\"br\", {}), \"\\n\", _jsxs(_components.p, {\n      children: [\"‘userName’이 초기화되기 전에 접근할 수 없다는 참조 에러가 뜨게 됩니다.\\n해당 코드 라인이 실행되는 시점에서 선언하지 않는 변수에 접근할 수 없는 게 우리가 예측할 수 있는 동작이므로 안심이 됩니다.\\n그런데 한 가지 의문인 점은 왜 ReferenceError: userName is not defined가 아닌 걸까요?\\n그 이유는 const와 let 또한 호이스팅 현상이 발생하기 때문입니다. 다만 var와의 차이점은 \", _jsx(_components.strong, {\n        children: \"const와 let은 호이스팅과 동시에 변수가 초기화 되지 않는다는 것\"\n      }), \"입니다.\\n\", _jsx(HighlightText, {\n        type: \"background\",\n        fontWeight: 700,\n        children: \"TDZ(Temporal Dead Zone)\"\n      }), \", 일시적 사각지대라고 하여 \", _jsx(_components.strong, {\n        children: \"변수 선언이 인식된 후 변수가 초기화 되기 전까지의 구간에서 const와 let 키워드로 선언한 변수에 접근하면 참조 에러가 발생\"\n      }), \"하게 됩니다.\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"const와 let으로 선언한 변수는 자바스크립트 엔진이 변수 선언문에 도달했을 때 초기화되고 접근이 가능해집니다. 이때 \", _jsx(_components.strong, {\n        children: \"const는 재할당이 불가능하기 때문에 초기화와 동시에 값이 할당\"\n      }), \"되어야 합니다. let은 할당 값이 없다면 undefined로 초기화됩니다.\"]\n    }), \"\\n\", _jsx(\"br\", {}), \"\\n\", _jsx(_components.h4, {\n      children: \"const의 호이스팅\"\n    }), \"\\n\", _jsx(\"br\", {}), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"https://drive.google.com/uc?export=view\u0026id=1e6ONONIaXB_0jj3nXJUnFdZbrImqp5EH\",\n        alt: \"const의 호이스팅\"\n      })\n    }), \"\\n\", _jsx(\"br\", {}), \"\\n\", _jsxs(_components.blockquote, {\n      children: [\"\\n\", _jsxs(_components.ol, {\n        children: [\"\\n\", _jsxs(_components.li, {\n          children: [\"변수 선언이 끌어올려진 후 초기화 되지 않아 접근할 수 없음 \", _jsx(\"br\", {}), \"(ReferenceError: Cannot access 'password' before initialization)\"]\n        }), \"\\n\", _jsx(_components.li, {\n          children: \"값을 재할당 할 수 없는 상수(constant)이기에 초기화와 동시에 할당\"\n        }), \"\\n\", _jsx(_components.li, {\n          children: \"할당된 값 123456 출력\"\n        }), \"\\n\"]\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(\"br\", {}), \"\\n\", _jsx(_components.h4, {\n      children: \"let의 호이스팅\"\n    }), \"\\n\", _jsx(\"br\", {}), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"https://drive.google.com/uc?export=view\u0026id=1IwziOv60kqGAzwjJjoAO8oqOFbVeNE-v\",\n        alt: \"let의 호이스팅\"\n      })\n    }), \"\\n\", _jsx(\"br\", {}), \"\\n\", _jsxs(_components.blockquote, {\n      children: [\"\\n\", _jsxs(_components.ol, {\n        children: [\"\\n\", _jsxs(_components.li, {\n          children: [\"변수 선언이 끌어올려진 후 초기화 되지 않아 접근할 수 없음 \", _jsx(\"br\", {}), \"(ReferenceError: Cannot access 'password' before initialization)\"]\n        }), \"\\n\", _jsx(_components.li, {\n          children: \"선언 후 값을 할당하지 않으면 undefined로 초기화\"\n        }), \"\\n\", _jsx(_components.li, {\n          children: \"초기화 된 undefined 출력\"\n        }), \"\\n\", _jsx(_components.li, {\n          children: \"값 123456 할당\"\n        }), \"\\n\", _jsx(_components.li, {\n          children: \"할당된 123456 출력\"\n        }), \"\\n\"]\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(\"br\", {}), \"\\n\", _jsx(_components.h2, {\n      children: \"var를 지양해야 하는 이유\"\n    }), \"\\n\", _jsx(\"br\", {}), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"재선언이 가능해 기존 선언을 덮어 쓸 수 있는 위험이 있습니다.\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"호이스팅으로 인하여 변수 선언문 이전에 변수에 접근 가능한 예기치 못한 동작이 발생합니다.\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"함수 스코프이기 때문에 if문, for문 등 문에서 쓰인 변수가 전역 변수가 되어 코드 여기 저기서 접근이 가능하고 변수 간 충돌이 발생할 수 위험이 있습니다.\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(\"br\", {}), \"\\n\", _jsx(_components.p, {\n      children: \"=\u003e 따라서 코드의 예측 가능성과 안정성을 저하시키는 var를 지양하고 이를 보완하기 위해 나온 const와 let을 사용하는 것을 적극 권장합니다👍\"\n    }), \"\\n\", _jsx(\"br\", {}), \"\\n\", _jsx(_components.h2, {\n      children: \"포스팅을 마치며\"\n    }), \"\\n\", _jsx(\"br\", {}), \"\\n\", _jsx(_components.p, {\n      children: \"이렇게 var의 특징과 그 특징으로부터 발생하는 위험성에 대해 알아보았습니다. var를 사용하면 코드가 일단 돌아는가지만 왜 돌아가는지 혼란스럽고, 왜 여기서 내가 예상한 동작과 다른 버그가 발생하는지 파악하는 데 시간을 허비하게 될 가능성이 크겠죠. 그렇기 때문에 요즘에는 var를 사용하지 않는 추세입니다. 다만 사용하지 않으니 알아두지 않는 것이 아니라 어떤 특징을 가지고 있었는지, 그 특징으로부터 어떤 불편함이 발생했는지, 불편을 해소하기 위해 어떻게 해야 하는지 알아두는 것이 중요하다고 생각합니다. 그리고 ES6가 나온 이후에 개발을 시작한 것이 얼마나 큰 행복인지도요🥹\"\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, props)\n  })) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\nfunction _missingMdxReference(id, component) {\n  throw new Error(\"Expected \" + (component ? \"component\" : \"object\") + \" `\" + id + \"` to be defined: you likely forgot to import, pass, or provide it.\");\n}\n","frontmatter":{},"scope":{}}},"__N_SSG":true},"page":"/posts/[category]/[slug]","query":{"category":"Javascript","slug":"var는-왜-더이상-사용되지-않을까"},"buildId":"D2kP1jcyZ981G6yj10vNT","assetPrefix":"/dev-log","isFallback":false,"dynamicIds":[74237,38452,92703,79814,11925,33711],"gsp":true,"scriptLoader":[]}</script></body></html>